# 主要な型と演算子

{{ TOC }}

## 概要

Pythonに限らずプログラミング初心者がプログラミングを書けるようになるには「使用頻度の高い重要な型を覚える」ことが大事です。
重要な型はどのような処理を作る際にも、プログラムの「つなぎ」として使われます。
つまりそれらなしにはどのようなプログラムを組むこともできないということです。

Pythonで一般的に使われる型は10以上はありますが、そのなかでも特に大事なのは以下の4つです。

* 数値型
* 文字列型
* Bool型
* リスト型

これらの型の詳細を理解するにはPythonの基礎を一通り抑えることが必要です。
このページではそれほど難しくない簡単だけれども重要な項目のみに絞って説明します。

## 数値型

### Pythonの整数型と小数型

Pythonで数値を扱うのは簡単です。
特に難しいことを考えなくてもおおよそ思った通りに動きます。

実は今まで数を扱う「数値型」と説明してきましたが、厳密にはそのようなものはありません。
あるのは整数を扱う「*整数型*」と、少数を扱う「*少数型*」です。
整数型と少数型は、英語ではそれぞれ「int」と「float」となります。

```text
>>> type(123)
<class 'int'>
>>> type(0.456)
<class 'float'>
```

C言語やJava言語では整数型と少数型を明確に区別してプログラムを書かないと、期待通りに動いてくれません。
たとえば整数型の変数に少数を代入すると丸められてしまったり、整数型も上限値が決められていたりします。
数値を表現する型は主要なものだけでも4つあり、それらの特徴をきちんと理解していないと数を使いこなせません。

ただ、Pythonは整数と少数の区別なく使うことができ、変数に少数を代入してもそれが勝手に整数に丸められることはありません。
同様に整数の上限も特に決まっていないため、非常に大きな数の計算も桁を考えずに実行できます。
これが今までの説明で整数型や少数型といわず、数値型としてきた理由です。

```text
>>> 123 + 0.456
123.456
>>> 123456789123456789123456789 + 123456789123456789123456789
246913578246913578246913578
```


### 計算に使う演算子

数値型(整数型と少数型)でどのような処理ができるかという話に移りましょう。
数と数の計算に使用する「+」や「-」といった記号は「*演算子*」と呼びます。
変数への代入に利用する「=」はこの演算子の一つで代入演算子と呼ばれています。
ただ、計算ではなく代入処理に使うため、「+」や「-」とは少し異なります。

演算子の演算対象となる値は「*オペランド*」と呼ばれます。
たとえば、計算式「1 + 2」の演算子は「+」であり、そのオペランドは「1」と「2」です。

```text
>>> 1 + 2
3
```

Pythonの数値計算で使う初歩的な演算子は以下となります。
「+」や「-」は分かるかと思いますが、掛け算は算数や数学で使う記号ではなく「\*」を使います。
割り算は分数の「/」だと思えば分かりやすいでしょう。

| 利用可能な演算子 | 説明 |
|:-------------:|:---:|
| M + N | 足し算 |
| M - N | 引き算 |
| M * N | 掛け算 |
| M / N | 割り算 |

これら以外にも数値計算の演算子はありますが、それらは数値型のページにて扱います。

### 演算子の優先度

算数の授業で習ったかもしれませんが、足し算や掛け算には優先順位があります。
たとえば「1 + 2 x 3」という計算をする場合、足し算よりも掛け算が優先されるため、
「1 + 2」より先に「2 x 3」が計算されて、答えは7になります。

Pythonでも掛け算が足し算よりも優先されるため、「1 + 2 x 3」の計算結果は7となります。

```text
>>> 1 + 2 * 3
7
```

算数で掛け算よりも足し算を優先する場合は「足し算を()で囲む」ことをします。
Pythonでも同じことができます。

```text
>>> (1 + 2) * 3
9
```

演算子の優先度は掛け算と割り算の優先度が高く、足し算と引き算の優先度がそれより低くなっています。
そして代入演算子の優先度は低いです。
まずはこれだけ覚えて下さい。

演算子の優先度が分かりにくい場合は「()」で囲むことで明示的に示すようにしてください。
「()」を使わなくても正しい場合であっても、結果が複雑な優先度によって求められる場合は「()」を使うほうが分かりやすいです。

### 複合代入演算子

変数のページで扱った「*複合代入演算子*」は、演算子の左側の変数に「その変数自身と演算子の右側の演算結果」を代入するのでした。
この複合代入演算子の動きは、数値計算の演算子と対応しています。
たとえば「+=」と「+」は対応しており、「\*=」と「\*」が対応しています。

| 利用可能な演算子 | 説明 |
| M += N | M = M + N |
| M -= N | M = M - N |
| M *= N | M = M * N |
| M /= N | M = M / N |

```text
>>> a = 5
>>> a += 3
>>> print(a)
8
```

複合代入演算子でよく使われるのは「+=」です。
同じ処理の繰り返し(ループ)で何回ループしたかをカウントしたり、
変数に格納された文字列に別の文字列を追加するといった処理でよく利用されます。

他のプログラミング言語ですとループのカウントに「*インクリメント*」と呼ばれる手法をよく使います。
ただ、Pythonにはインクリメント機能がないため、複合代入演算子で代用します。

```java
int i=0;
i++;
```

```python
i = 0
i += 1
```


### 少数

必要であれば少数も利用されます。
例えば「整数÷整数」も必要があれば少数になります。

```
>>> 5 / 3
1.6666666666666667
>>> 5 // 3  # // は整数になる除算(切り捨て)
1
```

## 文字列型

プログラミングでは、テキストデータを扱うことが非常に多いです。
そのため、テキストデータを扱う「文字列型」を使いこなせるようになることが重要です。

数字はそのまま書けば認識されていましたが、文字列は「特別な記号」でテキストを囲むことではじめて、
Pythonで解釈できるようになります。今まで特にことわりなくシングルクオテーション「'」を使っていましたが、
それも文字列を作る特別な記号のうちのひとつです。

たとえば以下のようにつかいます。

```
text = 'abcdefg'
```

テキストも数値と同じように演算することができます。
先に示したように「+」で結合もできますし、あまり知られていませんが「\*」で同じ文字列を繰り返すこともできます。

```
>>> text = 'hello' + ' python'
>>> print(text)
hello python
>>> text = 'hello' * 3
>>> print(text)
hellohellohello
```

### 文字列作成記号

プログラム中で文字列を作成する方法は主に3つあります。

Python で最もスタンダートなのは文字列型にしたいテキストをシングルクオテーション「'」で囲むというものです。
空白文字もそのまま含めることができます。

```
>>> text = 'hello python'
>>> print(text)
hello python
```

タブや改行といった特殊な文字はエスケープ処理をすることで加えることができます。
たとえば改行は、"\n"と表現されます。
英語キーボードの半角の\(バックスラッシュ)と日本語キーボードの¥は同じ意味なので、¥n(円記号は半角)も改行の意味を持ちます。

```
>>> print('hello \n python')
hello
 python
```

わかりやすいように\nの前後に空白をいれましたが、
改行させたいだけの場合は空白は不要です。
'hello\npython'と書けば改行コードが入ります。

文字列を作る別の方法はテキストをダブルクオテーション「"」で囲むというものです。
シングルクオテーションとほぼ同じです。
ほかのプログラミング言語だとダブルクオテーションのほうがよく使われるので、Pythonでもこちらを好んで使う人がいます。

シングルクオテーションとダブルクオテーションの使い分けは特に決まったものはないのですが、
「シングルクオテーションをダブルクオテーションで囲むと文字として扱われる」というルールがあるので、
文字列の中にシングルクオテーションを使いたい場合はダブルクオテーションを使うと便利です。

```
>>> print("it's nice!!")
it's nice!!
>>> print('it\'s nice!!')
it's nice!!
```

2つめの例のようにエスケープ記号を使うことで、
シングルクオテーションの中でシングルクオテーションを使うこともできます。
ダブルクオテーションでシングルクオテーションを囲むのと同じように、
シングルクオテーションでダブルクオテーションを囲むこともできます。
その効果はまったく同じで、ダブルクオテーションをエスケープせずに文字列で使うことができるというものです。

### トリプルクオテーション

最後の方法はトリプルクオテーションというものです。
これはテキストをシングルクオテーションかダブルクオテーションの3つで囲むというものです。
トリプルクオテーションで囲まれると、その中身が見たままにテキストとして表示されます。
例えば以下のようになります。

```
>>> text = '''it's nice!!'''
>>> print(text)
it's nice!!
```

プロンプトでは使えませんが、ファイルにプログラムを書き込む場合は、
改行も含めてひとつのテキストにすることが可能です。
たとえば以下をPythonのプログラムファイルに書きます。

```python
text = '''hello
python'''
print(text)
```

そしてそれを実行すると、以下のような出力がされます。

```
hello
python
```

一つの print 文で複数行の文字列が出力されていることが分かります。


## Bool型

Boolは別名「真偽値」とも呼ばれる型です。
真偽値という名前を聞くとなんだか難しそうに思えるかもしれませんが、
要するにYES/NOに相当する「True/False」という「正か非」の2値しかない単純な型です。

Pythonのプログラム中で "True" と "False" は特別なキーワードとして扱われます。
それぞれその言葉のとおりに、YES/NOとしてPythonに解釈されるのです。
このようなキーワードのことを「予約語」と呼び、予約語は変数名や関数名に使うことはできません。

### 比較演算子

Boolは「比較演算子」と呼ばれる記号で2つの値を比較した際に返されます。
例として数字の大小を比較してみます。

```
>>> 10 > 5
True
>>> 10 < 5
False
>>> a = 10 > 5
>>> a
True
```

特に難しいことはありませんね。「10は5より大きい -> True(YES)」とされていますし、
「10は5より小さい -> False(NO)」とされています。Boolを変数に格納することも当然できます。

比較演算子の一覧を以下に記載します。

| 利用可能な演算子 | 説明 |
| A == B | AとBが同一ならTrue |
| A != B | AとBが異なればTrue |
| A > B | A が B より大きければ True |
| A >= B | A が B 以上なら True |
| A < B | A が B より小さければ True |
| A <= B | A が B 以下なら True |

以下に例を書いてみます。

```
>>> 'hello' == 'world'
False
>>> 'hello' != 'world'
True
>>> 5 > 4
True
>>> 5 > 5
False
>>> 5 >= 5
True
```

## リスト

リスト(List)が本章で紹介する最後の型です。
名前からわかるようにデータを「リスト」状に複数個並べたような型です。
今までの数値や文字列に比べると使いどころがよくわからないかもしれないので、まずは例を示します。

### リストの役割

たとえば生徒のテストの点数を管理するアプリケーションを書くとします。
リストを使わずに3人の生徒の平均点を求めようとすると、以下のようなコードが書けます。

```
student1 = 68
student2 = 81
student3 = 49
average = (student1 + student2 + student3) / 3
print(average)
# 66
```

生徒ごとに変数を作って、そこから平均値を求めています。
それほど難しくはありませんね。ただ、上記のプログラムには問題があります。
たとえば生徒の数が4人になった場合などに修正する箇所が多くなってしまうことです。
生徒が40人だと変更はもっと大変です。

このような問題は、リストを使うことでかなり解消できます。
リストは「リストというデータの中に複数のデータを格納できる」という型ですので、
「生徒達の点数」というデータに「具体的な各生徒の点数」を格納します。
リストを使うと先のプログラムは以下のようになります。

```
results = [68, 81, 49]
average = sum(results) / len(results)
print(average)
# 66
```

1行目では「生徒たちの点数」というリストを作成しています。
見ればわかると思いますが、リストは [] の記号のなかにコンマ区切りでデータを羅列することで作成されます。
2行目にあるsum()はリスト内にあるデータの合計値を算出する関数で、
len()はリストに格納されるデータの数を返す関数です。
ここでは平均値を求めるために「生徒の点数の合計値/生徒の人数」としています。

2つめのコードは生徒一人ひとりの点数ごとに変数を作成していないので、
「複数の生徒たちの点数の格納」も簡単ですし、なにより平均値の算出方法が生徒の数に依存していません。
このようにリストを使うことで「ひとつのグループに属するデータ」を便利に扱うことができます。

リストの概念を以下に記します。

![image](./0035_image/01.jpg)

リストに含まれるデータは「要素(Element)」と呼ばれます。
たとえば上記図でいうと1番目の要素は68であり、2番目の要素は81 となります。

### リストの作成

リストがどのようなものかわかっていただけたかと思いますので、
操作方法について例を交えながら説明していきます。
リストの作成は以下のように [] 記号でリストの要素を囲むことで実現できます。

```
>>> a = []
>>> b = [1, 2, 3]
>>> c = ['A', 'B', 'C']
```

[] の中に何も入れない場合は空のリストを作成します。
なかに数字や文字列、及びその他の型をコンマで区切って書くことにより、それらを要素とするリストを作成することができます。

次にリストの「要素」を取り出したり、書き換えたりする方法を示します。
先の b = [1,2,3] では要素数が3つあるリストを作成していて、その中身は1、2、3となっています。
この中身にアクセスするにはリスト内の「x番目の要素を指定」する必要があります。
その方法は、「リスト名[要素の番号]」となります。

ただ、気をつけなければいけないのは、指定する順序は1からではなく0からということです。たとえば、以下のように使います。

```
b = [1,2,3]
print(b[0]) # -> 1
print(b[2]) # -> 3
b[1] = 5
print(b[1]) # -> 5
```

ちなみに、この「x番目」ということを「インデックス番号」と呼びます。
b[2]は、「リストbのインデックス番号が2の要素」という意味になります。
リストの値を参照するだけでなく、上書きもできています。
