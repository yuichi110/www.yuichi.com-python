# 主要な型と演算子

{{ TOC }}

## 概要

Pythonに限らずプログラミング初心者がプログラミングを書けるようになるには「使用頻度の高い重要な型を覚える」ことが大事です。
重要な型はどのような処理を作る際にも、プログラムの「つなぎ」として使われます。
つまりそれらなしにはどのようなプログラムを組むこともできないということです。

Pythonで一般的に使われる型は10以上はありますが、そのなかでも特に大事なのは以下の4つです。

* 数値型
* 文字列型
* Bool型
* リスト型

これらの型の詳細を理解するにはPythonの基礎を一通り抑えることが必要です。
このページではそれほど難しくない簡単だけれども重要な項目のみに絞って説明します。

## 数値型

### Pythonの整数型と小数型

Pythonで数値を扱うのは簡単です。
特に難しいことを考えなくてもおおよそ思った通りに動きます。

実は今まで数を扱う「数値型」と説明してきましたが、厳密にはそのようなものはありません。
あるのは整数を扱う「*整数型*」と、少数を扱う「*少数型*」です。
整数型と少数型は、英語ではそれぞれ「int」と「float」となります。

```text
>>> type(123)
<class 'int'>
>>> type(0.456)
<class 'float'>
```

C言語やJava言語では整数型と少数型を明確に区別してプログラムを書かないと、期待通りに動いてくれません。
たとえば整数型の変数に少数を代入すると丸められてしまったり、整数型も上限値が決められていたりします。
数値を表現する型は主要なものだけでも4つあり、それらの特徴をきちんと理解していないと数を使いこなせません。

ただ、Pythonは整数と少数の区別なく使うことができ、変数に少数を代入してもそれが勝手に整数に丸められることはありません。
同様に整数の上限も特に決まっていないため、非常に大きな数の計算も桁を考えずに実行できます。
これが今までの説明で整数型や少数型といわず、数値型としてきた理由です。

```text
>>> 123 + 0.456
123.456
>>> 123456789123456789123456789 + 123456789123456789123456789
246913578246913578246913578
```


### 計算に使う演算子

数値型(整数型と少数型)でどのような処理ができるかという話に移りましょう。
数と数の計算に使用する「+」や「-」といった記号は「*演算子*」と呼びます。
変数への代入に利用する「=」はこの演算子の一つで代入演算子と呼ばれています。
ただ、計算ではなく代入処理に使うため、「+」や「-」とは少し異なります。

演算子の演算対象となる値は「*オペランド*」と呼ばれます。
たとえば、計算式「1 + 2」の演算子は「+」であり、そのオペランドは「1」と「2」です。

```text
>>> 1 + 2
3
```

Pythonの数値計算で使う初歩的な演算子は以下となります。
「+」や「-」は分かるかと思いますが、掛け算は算数や数学で使う記号ではなく「\*」を使います。
割り算は分数の「/」だと思えば分かりやすいでしょう。

| 利用可能な演算子 | 説明 |
|:-------------:|:---:|
| M + N | 足し算 |
| M - N | 引き算 |
| M * N | 掛け算 |
| M / N | 割り算 |

これら以外にも数値計算の演算子はありますが、それらは数値型のページにて扱います。

### 演算子の優先度

算数の授業で習ったかもしれませんが、足し算や掛け算には優先順位があります。
たとえば「1 + 2 x 3」という計算をする場合、足し算よりも掛け算が優先されるため、
「1 + 2」より先に「2 x 3」が計算されて、答えは7になります。

Pythonでも掛け算が足し算よりも優先されるため、「1 + 2 x 3」の計算結果は7となります。

```text
>>> 1 + 2 * 3
7
```

算数で掛け算よりも足し算を優先する場合は「足し算を()で囲む」ことをします。
Pythonでも同じことができます。

```text
>>> (1 + 2) * 3
9
```

演算子の優先度は掛け算と割り算の優先度が高く、足し算と引き算の優先度がそれより低くなっています。
そして代入演算子の優先度は低いです。
まずはこれだけ覚えて下さい。

演算子の優先度が分かりにくい場合は「()」で囲むことで明示的に示すようにしてください。
「()」を使わなくても正しい場合であっても、結果が複雑な優先度によって求められる場合は「()」を使うほうが分かりやすいです。

### 複合代入演算子

変数のページで扱った「*複合代入演算子*」は、演算子の左側の変数に「その変数自身と演算子の右側の演算結果」を代入するのでした。
この複合代入演算子の動きは、数値計算の演算子と対応しています。
たとえば「+=」と「+」は対応しており、「\*=」と「\*」が対応しています。

| 利用可能な演算子 | 説明 |
| M += N | M = M + N |
| M -= N | M = M - N |
| M *= N | M = M * N |
| M /= N | M = M / N |

```text
>>> a = 5
>>> a += 3
>>> print(a)
8
```

複合代入演算子でよく使われるのは「+=」です。
同じ処理の繰り返し(ループ)で何回ループしたかをカウントしたり、
変数に格納された文字列に別の文字列を追加するといった処理でよく利用されます。

他のプログラミング言語ですとループのカウントに「*インクリメント*」と呼ばれる手法をよく使います。
ただ、Pythonにはインクリメント機能がないため、複合代入演算子で代用します。

```java
int i=0;
i++;
```

```python
i = 0
i += 1
```

### 0による割り算

算数や数学で学んだように、0で何かを割ることは禁じられています。
0で割り算をすると、その場でエラーが発生します。

```text
>>> 10 / 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
```

上記のように直接0で割ることはないと思いますが、
ある変数で割り算をする場合に、その変数に0が代入されているというシナリオはよくあります。
条件分岐で変数の値が0でない確認をし、0であった場合は別の対応をする必要があります。

### 少数

Pythonの少数は整数の扱いとほぼ同じです。
割り算などでも勝手に少数となります。

```text
>>> 5 / 2
2.5
```

少数について気をつけて頂く必要があるのは、
計算は2進数で行われるため誤差が生じる場合があるということです。
たとえば以下の計算結果はおそらく想定しているものと違うでしょう。

```text
>>> 123 + 123.456
246.45600000000002
```

少数を整数に変換する方法は四捨五入や切り上げ、切り捨てなど様々な方法があります。
これらの手法については数値型のページにて扱います。

## 文字列型

プログラミングでは、テキストデータを扱うことが多いです。
「文字列型」はテキストデータを扱う型なので、プログラミングができるようになるには文字列型の習熟が欠かせません。

### 文字列作成記号

数字はそのまま書けば認識されていましたが、
文字列は「特別な記号」でテキストを囲むことでPythonが文字列と認識します。
(囲まなければ変数名だと判断されます)

今まで文字列を作る記号として「*シングルクオテーション*」と呼ばれる「*'*」を使っていましたが、
これは文字列を作る特別な記号のうちのひとつです。
以下のように使うのでした。

```text
>>> text = 'hello python'
>>> print(text)
hello python
```

実はシングルクオテーションだけでなく「*ダブルクオテーション*」と呼ばれる「*"*」でも文字列が作成できます。

```text
>>> text = "hello python"
>>> print(text)
hello python
```

特に両者に大きな違いはありませんが、「シングルクオテーションがPythonの標準的な書き方」であることと、
「シングルクオテーションの文字列の中ではダブルクオテーションが使える」こと、
またその逆の「ダブルクオテーションの文字列の中ではシングルクオテーションが使える」ことは覚えておいて下さい。

ダブルクオテーションを使うのは以下のように内部にシングルクオテーションを保つ場合のみにするのがよいかと思います。

```text
>>> text = "I'm taro"
>>> print(text)
I'm taro
```

シングルクオテーションで上記を囲んでいると、「I」だけが文字列と認識されて、その後ろで文法エラーが発生します。

```text
>>> text = 'I'm taro'
  File "<stdin>", line 1
    text = 'I'm taro'
              ^
SyntaxError: invalid syntax
```

### エスケープ処理

機械は文字を「*文字コード*」というルールにもとづいて表示しています。
その中にはアルファベットや数字だけでなく、タブや改行も特殊な文字として含まれています。
これらの特殊な文字は文字列の中で「*エスケープ処理*」をすることで表現できます。

エスケープ処理は「これからエスケープ処理をしますよ」と伝える目的の「*エスケープ記号*」の後に、
決められた文字を1つ続けることで行われます。
エスケープ記号とその後に続く文字で特別な意味を持ち、この組み合わせを「*エスケープシーケンス*」と呼びます。

エスケープ記号として「*バックスラッシュ*」と呼ばれる「*\*」を使うのが世界では一般的ですが、
日本語キーボード環境だと「*円記号*」と呼ばれる「*¥*」を使います。
日本語環境でも英語キーボードを使っていればバックスラッシュを使います。

### 代表的なエスケープシーケンス

以下に代表的なエスケープシーケンスを記載します。
バックスラッシュで書いていますが、円記号でも全く同じです。

| 利用可能な演算子 | 説明 |
|:-------------:|:---:|
| \\ | 「\」記号そのもの |
| \n | 改行 |
| \' | 「'」記号そのもの |
| \" | 「"」記号そのもの |

たとえば改行のエスケープシーケンス「\n」を使うと、文字列の中で改行がされます。

```text
>>> print('hello \n python')
hello
 python
```

わかりやすいように\nの前後に空白をいれましたが、
改行させたいだけの場合は空白は不要です。
'hello\npython'と書けば改行コードが入ります。

```text
>>> print('hello\npython')
hello
python
```

エスケープ記号を使えばシングルクオテーションの文字列の中のシングルクオテーションを文字列作成の記号ではなく単なる「'」として使うことができます。

```text
>>> text = 'I\'m taro'
>>> print(text)
I'm taro
```

このようにバックスラッシュや円記号は文字列中で特別な意味を持つため、
その記号自身を文字として扱うためには「\\」といったようにエスケープ記号自身をエスケープするという処理が必要になります。

### トリプルクオテーション

文字列を作るには「*トリプルクオテーション*」という手法もあります。
これはシングルクオテーション3つか、ダブルクオテーション3つを連続して書くというもので、
3つの組み合わせで文字列を囲みます。

```text
>>> text = '''hello python'''
>>> print(text)
hello python
```

文字列の前後で使う記号の種類は統一する必要がありますので、
前はシングルクオテーション3つで後ろはダブルクオテーション3つといったことはできません。
また、文字列の中にシングルクオテーションやダブルクオテーションを書くこともできます(3つは続けられません)。

プログラムファイルでトリプルクオテーションを使う場合は、
文字列を複数行にまたがせることができます。

```python
text = '''hello
python'''
print(text)
```

このプログラムを実行すると、以下のような出力がされます。

```text
hello
python
```

改行コードを文字列中に何度も出現させるよりは、
トリプルクオテーションを使って表示される形式のままに文字列を作ったほうが分かりやすいです。

このトリプルクオテーションを使った文字列の作成はコメントアウトにも使われています。
文字列を作成するだけではPythonの実行結果に違いは発生しないため、
プログラムのコード自体を文字列にしてしまうことで、影響を発生させないようにしています。
トリプルクオテーションを使ったコメントの使い方はコメントのページをご参照下さい。

### 文字列の演算

文字列も数値と同じように演算することができます。
先に示したように「+」で結合もできますし、
あまり知られていませんが掛け算である「\*」記号で同じ文字列を繰り返すこともできます。

```
>>> text = 'hello' + ' python'
>>> print(text)
hello python
>>> text = 'hello' * 3
>>> print(text)
hellohellohello
```

文字列と他の型(例えば数値型など)を結合して新しい文字列を作る場合は、
他の型を文字列型にキャストする必要があります。

## Bool型

Bool型は別名「真偽値」と呼ばれます。
真偽値という名前を聞くとなんだか難しそうに思えるかもしれませんが、
要するに真偽に相当する「True/False」という「YES/NO」「正/非」の2値しかない単純な型です。

Pythonのプログラム中で「*True*」と「*False*」という文字は予約語として登録されています。
それぞれその言葉のとおりに、YES/NOとしてPythonに解釈されます。

Bool型は今後学ぶ条件分岐やループ処理で利用されます。
たとえば条件を満たすTrueの場合は処理Aを実施し、
条件を満たさないFalseの場合は処理Bを実施するといったように、プログラムの制御に関わります。

Bool型は自分で「True/False」を直接プログラムに書くだけでなく、
「比較演算子」を使った演算結果や、関数の返り値として得られます。

Bool型は様々な箇所で使われていますので、
一箇所でまとめて扱うのではなく個別のテーマに付随する形で詳細を扱います。
具体的には以下のようにしています。

* Bool型の解説ページ : 全てに関わる一般的なことについて
* 個別の型の解説ページ : その型のBool型に関わる関数や演算子、処理について
* その他のページ : 解説する処理などに関わるBool型の使い方について

### 比較演算子

Boolは「比較演算子」と呼ばれる記号で2つの値を比較した際に返されます。
例として数字の大小を比較してみます。

```
>>> 10 > 5
True
>>> 10 < 5
False
>>> a = 10 > 5
>>> a
True
```

特に難しいことはありませんね。「10は5より大きい -> True(YES)」とされていますし、
「10は5より小さい -> False(NO)」とされています。Boolを変数に格納することも当然できます。

比較演算子の一覧を以下に記載します。

| 利用可能な演算子 | 説明 |
| A == B | AとBが同一ならTrue |
| A != B | AとBが異なればTrue |
| A > B | A が B より大きければ True |
| A >= B | A が B 以上なら True |
| A < B | A が B より小さければ True |
| A <= B | A が B 以下なら True |

以下に例を書いてみます。

```
>>> 'hello' == 'world'
False
>>> 'hello' != 'world'
True
>>> 5 > 4
True
>>> 5 > 5
False
>>> 5 >= 5
True
```

## リスト

リスト(List)が本章で紹介する最後の型です。
名前からわかるようにデータを「リスト」状に複数個並べたような型です。
今までの数値や文字列に比べると使いどころがよくわからないかもしれないので、まずは例を示します。

### リストの役割

たとえば生徒のテストの点数を管理するアプリケーションを書くとします。
リストを使わずに3人の生徒の平均点を求めようとすると、以下のようなコードが書けます。

```
student1 = 68
student2 = 81
student3 = 49
average = (student1 + student2 + student3) / 3
print(average)
# 66
```

生徒ごとに変数を作って、そこから平均値を求めています。
それほど難しくはありませんね。ただ、上記のプログラムには問題があります。
たとえば生徒の数が4人になった場合などに修正する箇所が多くなってしまうことです。
生徒が40人だと変更はもっと大変です。

このような問題は、リストを使うことでかなり解消できます。
リストは「リストというデータの中に複数のデータを格納できる」という型ですので、
「生徒達の点数」というデータに「具体的な各生徒の点数」を格納します。
リストを使うと先のプログラムは以下のようになります。

```
results = [68, 81, 49]
average = sum(results) / len(results)
print(average)
# 66
```

1行目では「生徒たちの点数」というリストを作成しています。
見ればわかると思いますが、リストは [] の記号のなかにコンマ区切りでデータを羅列することで作成されます。
2行目にあるsum()はリスト内にあるデータの合計値を算出する関数で、
len()はリストに格納されるデータの数を返す関数です。
ここでは平均値を求めるために「生徒の点数の合計値/生徒の人数」としています。

2つめのコードは生徒一人ひとりの点数ごとに変数を作成していないので、
「複数の生徒たちの点数の格納」も簡単ですし、なにより平均値の算出方法が生徒の数に依存していません。
このようにリストを使うことで「ひとつのグループに属するデータ」を便利に扱うことができます。

リストの概念を以下に記します。

![image](./0035_image/01.jpg)

リストに含まれるデータは「要素(Element)」と呼ばれます。
たとえば上記図でいうと1番目の要素は68であり、2番目の要素は81 となります。

### リストの作成

リストがどのようなものかわかっていただけたかと思いますので、
操作方法について例を交えながら説明していきます。
リストの作成は以下のように [] 記号でリストの要素を囲むことで実現できます。

```
>>> a = []
>>> b = [1, 2, 3]
>>> c = ['A', 'B', 'C']
```

[] の中に何も入れない場合は空のリストを作成します。
なかに数字や文字列、及びその他の型をコンマで区切って書くことにより、それらを要素とするリストを作成することができます。

次にリストの「要素」を取り出したり、書き換えたりする方法を示します。
先の b = [1,2,3] では要素数が3つあるリストを作成していて、その中身は1、2、3となっています。
この中身にアクセスするにはリスト内の「x番目の要素を指定」する必要があります。
その方法は、「リスト名[要素の番号]」となります。

ただ、気をつけなければいけないのは、指定する順序は1からではなく0からということです。たとえば、以下のように使います。

```
b = [1,2,3]
print(b[0]) # -> 1
print(b[2]) # -> 3
b[1] = 5
print(b[1]) # -> 5
```

ちなみに、この「x番目」ということを「インデックス番号」と呼びます。
b[2]は、「リストbのインデックス番号が2の要素」という意味になります。
リストの値を参照するだけでなく、上書きもできています。
