## 位置引数とキーワード引数

関数の引数の使い方については既に何度も説明しています。
例えば以下の関数があるとしましょう。

```python
def test(a, b, c):
  print(a)
  print(b)
  print(c)
```

この関数は引数として a, b, c を受け取ります。
この関数を呼び出す際に a, b, c に対応した順序で引数を与えます。

```python
test(1,2,3)
# 1
# 2
# 3
```

出力をみると分かりますが呼び出しの引数の順序と関数の定義の引数の順序が合致していることが分かります。
このように関数の引数をその位置を使って指定することから、このような引数の使い方を「位置引数」と呼んでいます。

実は関数の引数は位置引数以外に「キーワード引数」と呼ばれる使い方ができます。
具体的には関数を呼び出す際に仮引数(定義された引数名)に対して実引数を与えるとキーワード引数として使われます。
具体的には以下の様な使い方です。

```python
def test(a, b, c):
  print(a)
  print(b)
  print(c)

test(b='B', c='C', a='A')
# A
# B
# C
```

関数の定義自体は最初の例と全く代わりませんが、呼び出し時に「b=’B’」といった形で値を与えています。
指定する引数の順番としては b, c, a なのですが、
呼び出し側では定義された順序の a, b, c で解釈されていることが分かります。
位置で引数を指定するのではなく、引数名という「キーワード」で引数を指定するのでキーワード引数と呼ばれています。
今回のようなシンプルな関数の定義だとキーワード引数で呼び出す必要はありませんが、
次に説明する「デフォルト引数を使う関数」や
「キーワード引数を使うことを前提に定義された関数」を使う関数を使う場合に利用されます。

## デフォルト引数

デフォルト引数は引数定義時にデフォルトの値を決めてしまい、
呼び出し時に対応する引数が与えられなければデフォルト値が適用されるというものです。
デフォルト引数は関数定義の引数の箇所に「引数名 = 値」と定義することで実現できます。
以下にサンプルを記載します。

```python
def test(a, b='B', c='C'):
  print(a)
  print(b)
  print(c)
```

引数 a,b,c を見ると、b と c にはデフォルト引数が定義されていることが分かります。
この関数を呼び出すときに引数を3つ与えればそれぞれ a, b, c に与えられますが、
それ未満の数で呼び出すと足りないぶんはデフォルト値が使われます。
以下にこの関数の利用例を示します。

```python
test(1,2,3)
# 1
# 2
# 3

test(1,2)
# 1
# 2
# C

test(1)
# 1
# B
# C
```

出力を見ると引数が足りない場合はデフォルト値が使われていることが分かります。
デフォルト値を使う場合に気をつけてほしいことは、
デフォルト引数は必ず引数の後部でなければならないということです。
例えば以下のような使い方はできません。

```python
def test(a='A', b='B', c):
  print(a)
  print(b)
  print(c)

#    def test(a='A', b='B', c):
#            ^
#SyntaxError: non-default argument follows default argument
```

大量のデフォルト引数を持つ関数はキーワード引数との相性がいいです。例えば以下の例を見て下さい。

```python
def test(a, b='B', c='C', d='D', e='E', f='F'):
  print(a)
  print(b)
  print(c)
  print(d)
  print(e)
  print(f)

test('AA', d='DD')
# AA
# B
# C
# DD
# E
# F
```

上記サンプルの関数は非常に高度なもので、引数が6つとれるとしましょう。
ただ、細かい調整を引数で調整できるだけであり、最初の引数以外はそれほど重要でないとします。
全ての引数を指定するのは大変ですが、デフォルト引数の機能を使って必要な箇所のみピンポイントで指定し、
あとはデフォルト値を使うようにすれば呼び出しが簡単になります。

## 可変長引数

 可変長引数は名前の通り「引数の長さ(数)が変わる」ということです。
 先ほどのキーワード引数も良い出す際の引数の数はデフォルト値を使うか否かという観点では可変でした。
 ただ、可変長引数はそれとは異なり「好きなだけ」関数の定義をすることができます。
可変長引数を使う際は、関数を定義する際に引数の前に「\*」をつけます。
引数名はなんでもよいのですが、慣習的に args (日本語だと引数)といった名前を付けることが多いです。
読む人にとっても「これは可変長引数」と認識しやすいです。

```python
def test(*args):
  print(type(args))
  print(args)

test(1)
# <class 'tuple'>
# (1,)

test(1,2,3)
# <class 'tuple'>
# (1, 2, 3)

test()
# <class 'tuple'>
# ()
```

上記のサンプルを見てもらうと分かるように可変長引数はタプルとして渡されています。
呼び出し時にあたえられる引数の数は任意の数が使え、0 であっても問題ありません。

定義する可変長引数の位置を調整することで必要最低限の引数の数が決まります。
例えば `def test(a, *args):` とした場合、最初に与えられた引数が a に入り、
のこりが args に入ります。そのため、最低一つの引数が必要です。

```python
def test(a, *args):
  print(a)
  print(args)

test(1)
# 1
# ()

test(1,2,3)
# 1
# (2, 3)

test()
# Traceback (most recent call last):
#   ...
# TypeError: test() missing 1 required positional argument: 'a'
```

2つの引数が必要であれば `def test(a, b, *args):` とするなどして、
必要な数にマッチした関数の定義をしてください。

## なんでも受け取るキーワード引数

位置指定引数のところで紹介したキーワード引数は関数の引数の順序を無視して呼び出す目的で使いました。
実はこのキーワード引数は自分が定義した引数以外にも使えます。
以下のサンプルで関数定義の際に `**kargs` という引数を使っています。
これを使うと定義されていないキーワード引数を辞書型として扱うことができます。

```python
def test(**kargs):
  print(type(kargs))
  print(kargs)

test(a='A', hello=3)
# <class 'dict'>
# {'hello': 3, 'a': 'A'}

test()
# <class 'dict'>
# {}

test('A', 'B')
# Traceback (most recent call last):
#   ...
# TypeError: test() takes 0 positional arguments but 2 were given
```

上記の呼び出し結果と出力を見てもらうと分かりますが、
キーワード引数の引数名が辞書型の key になり、それに対応する値が value となっています。
`**kargs` はあくまでもキーワード引数専用であるため、
キーワードを指定しない位置引数を使った呼び出しをするとエラーとなっています。
なお、kargs は keyword args の省略形であり、
先ほどの args と同様に慣習としてこの名前を使うことが多いです。
他の変数名も使えますがあえて使う理由もありません。

かなり高度な使い方となるのですが、可変長引数とキーワード引数を併用することで
「どんな引数でも使える関数」を定義することができます。

```python
def test(*args, **kargs):
  print(args)
  print(kargs)

test(1,2,3,a='A',b='B',c='C')
# (1, 2, 3)
# {'a': 'A', 'b': 'B', 'c': 'C'}
```

この使い方で便利なのは関数を「呼び出す」場合にも `*arg` と `**kargs` を使えるということです。
それをすると「受け取った引数をそのまま別の関数に渡す」ということができます。
以下のサンプルを見ると test2 関数が受け取った引数を test1 関数に丸投げしていることがわかります。

```python
def test1(*args, **kargs):
  print('test1')
  print(args)
  print(kargs)

def test2(*args, **kargs):
  print('test2')
  # 可変長引数とキーワード引数をそのまま呼び出す関数に渡す
  test1(*args, **kargs)

test2(1,2,3,a='A',b='B',c='C')
# test2
# test1
# (1, 2, 3)
# {'a': 'A', 'b': 'B', 'c': 'C'}
```

今回は自分で作った test1 を呼び出していますが、たとえばここに既存の関数をいれることもできます。

```python
def test(*args, **kargs):
  print('args:   ', args)
  print('kargs:  ', kargs)
  result = sum(*args, **kargs)
  print('result: ', result)
  return result

result = test([1,2,3,4,5])
# sum([1,2,3,4,5])
print(result)
# args:    ([1, 2, 3, 4, 5],)
# kargs:   {}
# result:  15
# 15
```

上記のサンプルは sum 関数になにを与えるかをリッチに出力させています。
面白いのは関数 sum はキーワード引数を受け取らないのに呼び出し時にそれを与えても問題が発生していないところかと思います。


## メソッドのオーバーロード(デフォルト引数)

オブジェクト指向にはオーバーロードと呼ばれている概念があります。
オーバーライドと名前が似ているので注意してください。
オーバーロードを簡単に言ってしまうと「あるクラスに同名の引数が異なるメソッドを複数宣言すると、
呼び出し時の引数に応じて呼び出されるメソッドが変わる」というものです。
実はオーバーロードは Python にはありません。
ただ、オーバーロード相当のことは「デフォルト引数」や「可変長引数」などを使うことで実現できます。
以下にデフォルト引数を使ったオーバーロードもどきのサンプルを張ります。

```python
class MyClass:
  def test(self, a, b, c='C', d='D'):
  	print(a, b, c, d)
```

関数の可変長引数については前書で説明したためここでは詳細は扱いませんが、対応する引数を与えればそれになり、
あたえなければ = の後のデフォルト値になるという動きをします。
メソッドも同じことができます。
使用例は以下のようになります。

```python
mc = MyClass()
mc.test('AA', 'BB')
# AA BB C D

mc.test('AA', 'BB', 'CC')
# AA BB CC D
```

見てもらうと分かるように同名のメソッドを引数2でも引数3 でも呼び出すことができています。
