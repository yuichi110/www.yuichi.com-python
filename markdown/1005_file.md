# ファイル処理

{{ TOC }}

## 概要

あとで書く

## ファイル読み書きの全体像

### ファイルのオープンとクローズ

WindowsやMacでファイルを扱うには「ファイルがあるフォルダを開く(デスクトップ含む)」
「ファイルをダブルクリックなりしてアプリケーションで開く」
「ファイルを読み書きする」
「アプリケーションのウィンドウを閉じるなりしてファイルを閉じる」
という流れとなります。

プログラミングでのファイルの扱いもこれとほとんど同じです。
具体的には「ファイルを指定して開く」「ファイルを読み書きする」「ファイルを閉じる」という流れです。

ユーザーがファイルがある場所のフォルダを開いてファイルを指定するように、
プログラムでは「**パス**」と呼ばれるファイルの場所を指定する表記方法を使ってファイルを指定します。
Windowsでいえば「Cドライブにあるユーザーフォルダーにあるデスクトップフォルダのテキストファイルtest.txt」といった具合です。

そのようにして指定されたファイルを、読み込むか書き込むかといった「**モード**」を指定して開きます。
ファイルの内容を読み込みたいのであれば「読み込みモード」で開いて、
新しくファイルを書きたいのであれば「書き込みモード」で開きます。
ファイルを開くことは「**オープン**」と呼ばれています。

オープンモードに応じて読み込んだり書き込んだりする作業を行い、
その時点でファイルを使わなくなった際はファイルを閉じます。
ファイルを閉じることは「**クローズ**」と呼ばれています。

### ファイルオブジェクトを使った操作

オープンされたファイルを読み書きするには、「**ファイルオブジェクト(ファイル型のインスタンス)**」を使います。

リストの操作は「リスト型のインスンタンス」と「メソッド」を通じて行います。
たとえば要素を追加するのにappendメソッドを呼び出したりします。

ファイル操作もこれと同じで、
ファイルをオープンする際に返されれるファイル型のインスタンスを通して読み書きを実施します。
ファイルというOSの上にあるデータをPythonがファイル型のインスタンスとしてプログラマに提供し、
プログラマはそのインスタンスを使うことでファイルの読み書きを簡単に実現できます。

画面への出力の仕組みをprint関数が提供してくれるのと同じように、
ファイルの操作の仕組みをファイルオブジェクトが提供してくれています。


## テキストファイルの読み込み

デスクトップに以下の内容が書かれたファイル「text1.txt」があるとします。
内容と拡張子からわかるようにテキストファイルです。

```text
Hello
World
Python
```

このファイルを読み込んで、画面表示をするプログラムを作成します。
ファイルのパスを指定する方法は後ほど別途扱うので、ここでは話を単純にするために以下の状況を想定します。

* テキストファイルはデスクトップ上にある
* Pythonのプログラムはデスクトップ上にある
* Pythonを実行するコンソールはデスクトップに移動済み

この条件を満たす場合はファイルのパスを意識することなく、
プログラム中でファイル名を指定するだけでオープン処理をすることができます。

テキストファイルを読み込んで表示するプログラムは以下のものとなります。


```python
fin = open('text1.txt', 'r')

text = fin.read()
print(text)

fin.close()
```



```text
Hello
World
Python

```

プログラムの1行目では「**open関数**」を使ってファイルを開いています。
この関数の第一引数はファイル名もしくはファイルのパスです。
第二引数がファイルをオープンするモードで、ここでは「'r'」を指定しています。
これは読み込み(Readのr)となります。

このopen関数は開いたファイルのファイルオブジェクトを返り値として返します。
それを変数finに代入しています。
変数名は好きなものを利用できますが、「fin」は「file input」の略として読み込みモードで開いたファイルオブジェクトを格納する際によく使われる変数名です。

3行目ではfinに格納されるファイルオブジェクト(ファイル型のインスタンス)のメソッドであるreadを呼び出しています。
このメソッドはファイルの内容を全て読み込んで、それを文字列型で返すという働きをします。
つまり、今回は「'Hello\\nWorld\\nPython\\n'」という文字列を返しており、それが変数textに代入されています。
4行目のprint関数の結果からもそれが分かります。

最後の6行目がファイルをクローズする処理です。
利用し終わったファイルオブジェクトのcloseメソッドを呼び出すことで、ファイルが閉じられます。
ファイルを閉じたあとは読み込みや書き込みはできなくなります。
ファイルを閉じずに開きっぱなしにすると様々な理由でトラブルが発生する可能性があるため、
利用し終わった後はきちんとクローズをしてください。

### ファイル内の位置と行ごとの読み込み

テキストファイルをテキストエディタで開いた際に、カーソルが表示されます。
これは「何行目」「前から何文字め」といったテキストファイル内での位置情報を持っています。

ファイルオブジェクトのインスタンスにも「今どこにカーソルがあるか」という位置情報があります。
ただ、これはテキストエディタほど分かりやすいものでないため、
複雑なファイルをやりとりするサービスの開発以外で操作することは滅多にありません。

読み込みモードで開かれたファイルオブジェクトでは、最初のカーソル位置はファイルの先頭にあります。
readlineメソッドは「現在のカーソル位置から、次の改行コードまで」を読み込むメソッドです。
そのため、呼び出すごとに1行1行返します。

```python
fin = open('text1.txt', 'r')

text1 = fin.readline()
print('1: ' + text1)

text2 = fin.readline()
print('2: ' + text2)

fin.close()
```

```text
1: Hello

2: World

```

その行になにもない場合であっても改行コードはあるため、readlineメソッドは「'\\n'」を返します。
一方、readlineメソッドを繰り返してファイルの最後までたどり着いた場合は、空文字「''」を返します。
つまりreadlineメソッドの返り値が空文字であるか否かを調べることで、ファイルの最後まで読み込んだかを判定できます。


### for文を使ったファイル読み込み

readlineメソッドは文字列を1行1行読み込むことができますが、for文を使って同じことができます。

ファイルオブジェクトはリストなどと同じシーケンス型に属していて、
forで1回ループするごとに1行を読み込みます。

```python
fin = open('text1.txt', 'r')

for line in fin:
  print(line)

fin.close()
```

```text
Hello

World

Python

```

テキストファイルを全て読み込むのであればreadメソッドのほうが簡単です。
ただ、大きなファイル(たとえば1ギガ)を全て読み込むということは、それをPythonが全てメモリ上に持っておくということを意味しています。
リソース不足でプログラムに問題が発生する可能性が少なからずあります。

for文を使ってループ形式でファイルを読み込んでいくのであれば、
使うリソースは「次の1行を確保して、前の1行を開放」というかたちで処理をすることができるため、
まとめて読み込むよりも少なくなる傾向があります。

行ごとに何かをするプログラムを書くのであれば、
readメソッドした結果を行ごとに分割してやるのではなく、このfor文を使ったかたちで処理をするようにしてください。


## テキストファイルへの書き込み

### 上書き

### 追記

### バッファリング



## パスの指定


### OSがどうファイルを扱うか

OSにおけるファイル処理は主に以下のような流れとなります。

![image](./0090_image/02.jpg)

まず絶対パス(ルートやCドライブなどからのパス)や、
相対パス(現在いるディレクトリから指し示すパス)を使ってファイルを指定します。
それに対して読み、書き、読み書きなどのモードを指定してファイルをオープンします。
そして読み書きなどの必要な処理を繰り返し、処理がすべて完了したらファイルをクローズして終わりです。

読み書きなどの具体的な処理はそれほど難しくありません。
一言でいってしまえば、「テキストファイルは行ごとに処理する」
「バイナリファイルは先頭から何バイトめか(位置)を指定して処理する」ことです。
たとえば、テキストファイルで以下のものがあるとします。

```
world
python
java
```

この内容にすべて"hello "を加えて画面に表示するというプログラムを書く場合、
ループ処理を利用して以下のことを繰り返して処理するのが一般的です。

1.	行の内容を取得
2.	hello に行の内容を追加しprint
3.	次の行に進む

「テキストファイルは行ごとに処理する」のが基本であることを覚えておいてください。
バイナリファイルの扱いは後ほど簡単に扱いますが、Python でそれを専用ライブラリなしにやることはかなり稀かと思います。
私が過去にバイナリファイルを操作した際に利用した言語は C もしくは Objective-C でした。

## テキストファイルの読み込み

実際に pythonでテキストファイルの処理をどのようにするか紹介します。
先ほどのテキストファイルの処理方法さえ理解してしまえば非常に簡単です。


まずファイル 'txt.txt' をモード 'r(読み)' でオープンしています。
オープンしたファイルオブジェクトに対してfor文を使うと1行1行取得できるので、
行ごとにprintする処理をしています。
これを実行すると以下のような出力となります。

```
<type 'file'>
hello world

hello python

hello java
```

print文の改行に加えてもとのテキストの改行コードも表示されるので業の間にもう1行スペースがあいてしまっていますが、
この回避方法については先に説明した sys.stdout.write() を使うか後述する print 文の出力オプションを使います。

### ファイルの読み込みメソッド

ほかにはファイルを丸ごと読む方法もあります。

```python
f = open('text1.txt', 'r')
text = f.read()
print(text)

lines = text.split('\n')
print(lines)

f.close()
```

ファイルオブジェクトに対してreadメソッドを使うことで、
その中身をすべて文字列として取得します。
それを行ごとに処理したいのであれば、文字列を先に説明した改行コードで分割することで行ごとのリストになるので、
それに対して処理を行うことができます。
この処理方式はファイルを全て読み込むため、
容量の大きなファイルで実行しようとするとリソースを使いすぎてエラーになる可能性があります。
小さいファイルであれば問題無いですが、注意して利用して下さい。

コメント : 他のreadメソッドも追加すること

### ファイルへの書き込み(上書きと追記)

次にファイルへの書き込み方法について説明します。
書き込みも読み込みと大差ありませんが、ファイルをオープンする際に書き込みモードを指定します。
以下のテキストが既に書かれているテキストファイルtext2.txtに 123456 と書き込みをするとします。

```
Hello
```

書き込みのコードは以下となります。

```python
f = open('text.txt', 'w')
f.write('123')
f.write('456')
f.close()
```

コードを見てもらうと想像がつくとは思いますが、openの第二引数が書き込みモードの 'w' となっています。
そしてファイルオブジェクトにたいしてwriteすることで、実際にファイルに書き込み処理がされています。
そして最後にクローズするのは同じです。

書き込みされたファイル text2.txt は以下のようになりました。

```
123456
```

見てもらうとわかるように、もともとのテキストであるHelloが消えています。
ファイルが上書きされていることがわかります。

ただ、場合によっては「追記(もとの中身を残したまま後ろに加える)」しないといけないこともあります。
その場合はファイルをオープンするモードを 'a' の「追記」にすれば実現できます。
モードのみ修正して以下のコードにしてみます。

```python
f = open('text.txt', 'a')
f.write('123')
f.write('456')
f.close()
```

これを実行すると、以下のようになりました。

```
123456123456
```

もとの '123456' は残ったままで、その後ろに '123456' が新しく追加されています。
ファイルのオープンごとに以前の内容が消えないので、アプリケーションのログなどを取る際に便利な手法です。
なお、書き込みを「次の行」にする場合は改行コード”\n”をファイルに書き込めばそこで改行されます。

## バッファリング

ファイルへの読み書きをする際に知っておいてもらいたいのが「バッファリング」という処理です。
ご存知かもしれませんが、ハードディスクへのアクセス速度はメモリへのアクセス速度に比べて何桁も遅いです。
そのため、ファイルを何度も細かく読み書きすることを繰り返しているとプログラムが非常に低速になってしまいます。
この問題を防ぐために、出力があるたびに毎回ディスクに書き込むのではなく、
メモリ上の高速な一時領域にデータをおいておき、まとめてそれを読み書きするという処理が行われます。
こうすることで低速なディスクアクセスの回数が減らせるのでプログラムが高速化されます。
これがバッファリングの基本的な概念です。

以下にこれを図で示します。

![image](./0090_image/03.jpg)

このディスクへの書き込みは Python が判断して適切なタイミングで発生するようですが、
書き込みを強制的に行いたい場合はそこでflush()メソッドを使います。

```python
f = open('text3.txt', 'w')
f.write('123')
f.flush()
f.write('456')
f.close()
```

closeのタイミングで必ず書き込まれるので、今回のようにopenからcloseまで時間が短い場合はflushは不要です。
ただ、openしっぱなしで、なかなかcloseしないようなプログラムは適切なタイミングでflush するように心がけてください。
でないと、プログラムが強制終了されてしまった場合などに、ファイルに書き込みがされていない可能性があります。

## with/as によるファイル処理

withとasは「コンテキスト」を扱うための特別な構文です。
ほかの言語ではあまり見られない少々独特な概念なのですが、知っておいて損はないと思うので取り扱いたいと思います。
コンテキストの詳細については下編で扱います。

コンテキストという言葉は少しボヤッとしているのすが、
「ある特定の処理」を実行するための状態(モード)だと言えるかもしれません。
たとえばファイル処理なのですが、基本的には以下の流れとなります。

1.	ファイルをオープンする
2.	読み書き
3.	ファイルをクローズ

これは「ファイル処理のための状態(モード)に入っている」という状況です。
当然ながら自分で書くプログラムなので、ファイルを意図的にオープンしっぱなしにして何もしないことも可能ですが。
ただ、ほとんどの場合は単にファイルをクローズし忘れているだけです。

with と as は Python の文法として「ある一連の処理」を完遂することを目的に使うものです。
具体的には以下のように使います。

```python
with A as B
  処理
```

Aはコンテキストをサポートする特別なオブジェクトであり、Bはそれが代入されているのですが、ここでは深いことは気にせずファイル処理を with とas で行ってみます。
以下のコードを見てください。

```python
with open('text1.txt', 'r') as f:
  for line in f:
    print(line)
```

このプログラムは text1.txtを読み取り専用モードで開き、その中身を一行ずつプリントするというプログラムです。
注目して欲しいのは今までのように open 関数で作ったファイルオブジェクトを代入するのではなく、
with と as でコンテキストとして扱っていることです。
ここではopen('hello.txt', 'r')がコンテキストをサポートするファイルオブジェクトを返し、
それがfに格納されています。
そしてこのfを使ってファイル処理をしています。

一般的なopen関数と代入によるファイルオブジェクトの取得ではなく、
with/asを使うとファイルオブジェクトがクローズされることが保証されます。
