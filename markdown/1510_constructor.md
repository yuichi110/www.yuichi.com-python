# コンストラクタ

{{ TOC }}

## 概要

あとで書く

## コンストラクタの定義

### インスタンス作成時に呼び出される特殊なメソッド

クラスにデータを持たせる際に以下のように`def __init__`内に定義をするとお話しました。

```python
class UserInfo:
  def __init__(self):
    self.name = ''
    self.birth = 0
    self.address = ''
```

実はこの`__init__`は、「インスタンスが作成されるタイミングで呼び出される特殊なメソッド」です。
一般的にそのような処理をするメソッドは「コンストラクタ」と呼ばれており、
形は違えど Java や C++ といったオブジェクト指向の言語ではなんらかの形で実装されていることが多いです。
コンストラクトは「構築する」という意味なので、それをやるコンストラクタという名前になっています。

試しに__init__内にprint分を加えてインスタンスを作成し、コンストラクタの挙動を見てみます。

```python
class UserInfo:
  def __init__(self):
    print('initialize instance') # HERE
    self.name = ''
    self.birth = 0
    self.address = ''

taro = UserInfo()
# initialize instance
```

このプログラムを実行すると、インスタンスを作成した際に`__init__`内にあるprint文が呼び出されることがわかります。

### コンストラクタの引数

さて、このコンストラクタなのですが見てわかるように文法としてはメソッドの宣言そのもので、
名前が`__init__`ということ以外は特別なことはありません。
そのため、通常のメソッドと同じようにコンストラクタも引数を複数与えることができます。
このコンストラクタの引数はクラスをインスタンス化する際に利用されます。
実際にコンストラクタの引数の利用例を見たほうがわかりやすいと思うので、上記サンプルを改良して`__init__`に引数を与えてみます。

```python
class UserInfo:
  def __init__(self, name, birth, address):
    print('initialize instance')
    self.name = name
    self.birth = birth
    self.address = address
```

インスタンス作成時にコンストラクタで定義した引数に対応した値を渡します。
例のごとく`self`に相当するものは飛ばしています。

```python
taro = UserInfo('taro', 1980, 'tokyo')
# initialize instance

print(taro.name)
# taro
print(taro.birth)
# 1980
print(taro.address)
# tokyo
```

コンストラクタで定義した引数に対応した形で、インスタンス化が行われていることがわかります。
具体的には宣言である`def __init__(self, name, birth, address)`と、
呼び出しである`UserInfo('taro', 1986, 'tokyo')`の対応が取れています。
そしてコンストラクタ内では、与えられた引数をインスタンスのデータの初期化に利用しています。

### コンストラクタを使うメリット

コンストラクタの引数を使うと「インスタンスの初期化を実施する」という保証を与えることができます。
今までのようにコンストラクタを使わずに個別にデータを初期化する実装にすると特定のデータの初期化を忘れる可能性が考えられます。
一方、コンストラクタの引数を通して初期化を行うのであれば、
初期化を忘れるとそれは「プログラムのエラー」という形でその場ですぐにわかります。
そのため、きちんとテストをしていれば初期化を忘れることはありません。
インスタンス生成直後にインスタンス変数になにか値を設定することが必須であれば、それは必ずコンストラクタで設定されるべきです。
なお、コンストラクタ内の「`self.xxx = xxx`」の前者はインスタンスが持つインスタンス変数であり、
後者はコンストラクタの引数(メソッド内のローカル変数)なので別物です。
両者に別の名前を付けても構いませんが、同名にすると対応が分かりやすいためこのようにすることが多いです。

コンストラクタの役割はインスタンス変数の設定以外にもあります。
インスタンスを作るにあたり、なにか複雑な処理が必要であればそれはコンストラクタ内で実現されます。
たとえば設定ファイルを管理するクラスを作るのであれば、設定ファイルの存在の確認や既存の設定のロード処理などもコンストラクタの役割になるかもしれません。
ちなみに、コンストラクタは省略可能です。
インスタンス変数が存在しなかったり、上記のような初期化処理が不要だったりする場合は宣言しないでかまいません。
その場合はインスタンスが作成された際に何もしません。

なお、Pythonの`__init__`は、厳密には一般的なコンストラクタとは異なる別物という見解があります。
ただ、表面上は同様の動きをしてくれるため上級者以外は気にする必要はありません。
もう少しプログラマとしてのレベルがあがって、いろいろな言語を使えるようになってから調べてみると、面白いかもしれません。

### クラスの特殊属性

今までも利用してきたようにクラスやインスタンスには特殊な変数やメソッドがあります。
例えば`def __init__(self)`として定義されたメソッドはコンストラクタとして動くという「特殊な決まり」があります。
その他にも継承でお話したように`__class__`というインスタンス変数はクラス名を返します。

実はPythonではアンダースコア2つで囲われた変数やメソッドは特別な意味を持っています。
そして、そういったメソッドはオーバーライドをすることができます。
以下にサンプルコードを記載します。

```python
class Customer:

  def __init__(self, name, age):
  	self.name = name
  	self.age = age

  def print_info(self):
  	print('name: ' + self.name)
  	print('age:  ' + str(self.age))
```

まず上記のクラス Customer があるとします。インスタンス変数として name と age を持ち、
それらを表示するためのメソッド print_info もあります。
このクラスの情報を表示しようと思ったら print_info メソッドを呼び出す必要があり、
print 文にこのオブジェクトを渡しても自分が期待するような出力は得られません。

```python
c = Customer('taro', 25)
c.print_info()
# name: taro
# age:  25

print(c)
# <__main__.Customer object at 0x1019d8b38>
```

print文の出力を見てもらうと分かりますが、たんにオブジェクトの場所を表示しているだけです。
この挙動を変えるために特殊メソッド`__str__()`をオーバーライドします。
先に説明しましたが継承を明示的にしていないクラスは object というクラスを継承しています。
`__str__()`は object にてアドレス番地を出力するように実装されているので、自分のクラスでその挙動を上書きします。

```python
class Customer:

  def __init__(self, name, age):
  	self.name = name
  	self.age = age

  # 特殊メソッドのオーバーライド
  def __str__(self):
  	return 'name:{}, age:{}'.format(self.name, self.age)

c = Customer('taro', 25)
print(c)
# name:taro, age:25
```

新しく`__str__()`メソッドを定義したことで str() 関数で文字列化した場合に返される値が定義したフォーマットとなり、
print 文もその恩恵に預かります。

特殊属性の詳細は高度な話題となるため後編にて詳細を扱いますが、そのようなものが存在しているということは覚えておいて下さい。
