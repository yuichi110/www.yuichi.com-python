## ローカル変数

関数内では引数も含めて変数を宣言できます。
例えば以下の関数があるとしましょう。

```python
def test(x):
  a = x * 2
  return a

print(test(5))
# 10
```

これは与えられた引数を2倍して返すという単純な関数です。
内部に引数(関数内部では変数と同じ扱い)である x と変数 a が存在しています。
実はこれらの変数は関数の外からはアクセスできません。

なんとなくですが、上記の関数を呼び出す前に x や a にアクセスしたら問題が起きそうな気がするのは分かります。
なぜなら、一度も呼ばれていないから x や a になにも入っていないからです。
ただ、実際には関数を呼び出した後であっても関数内の引数や変数に関数外からアクセスすることはできません。

具体的には以下のようなエラーとなります。

```python
print(test(5))
# 10

print(x)
# Traceback (most recent call last):
# ...
# NameError: name 'x' is not defined

print(a)
# Traceback (most recent call last):
# ...
# NameError: name 'a' is not defined
```

重要なことなので覚えておいて下さい。

## グローバル変数

さっそくですが次のコードを見てください。

```python
x = 5

def add():
  x += 1

print(x)
add()
print(x)
```

このプログラムを実行するとどのようになると思いますか。
addという関数がxに1をインクリメントするので、以下のようになるでしょうか。

```
5
6
```

実行してみると分かりますが、実際はエラーが出てしまいます。

```
Traceback (most recent call last):
  File "/Users/yuichi/Desktop/hello.py", line 7, in <module>
    add()
  File "/Users/yuichi/Desktop/hello.py", line 4, in add
    x += 1
UnboundLocalError: local variable 'x' referenced before assignment
```

上記エラーを見ると、関数の中で「変数xに値が与えられる前に参照した」というような内容となっています。
結論から言いますと、プログラム1行目のxと関数内のxは別物です。
そのため関数内のxを使おうとしたところ、エラーが出てしまったのです。
関数内に存在しない1行目の変数xは「グローバルレベル」に存在する変数です。
一方、関数内は「その関数のレベル」で変数などが定義されています。
そのため、グローバルレベルの変数を関数内で使いたい場合は、
関数がそれを利用できるように「global 変数名」と宣言をしてあげる必要があります。
具体的には以下のようになります。

```python
x = 5

def add():
  global x  # global宣言
  x += 1
```

こうすることで、関数の外で定義された変数xを関数の中で利用することができるようになります。
他のプログラミング言語の経験者であればグローバルレベルから関数内の変数を見れないことを知っている人は多いのですが、
Python にはその逆があることを知らないことが時々あるようです。
グローバルレベルと先程説明した関数レベルの変数のアクセスについて以下の図にまとめます。

![image](./0045_image/02.png)

関数内からグローバルは global 宣言すれば見えるが、グローバルレベルから関数内の変数や引数は見えない。
基本的にはこのルールさえ守れば問題ありません。

ただ、実はglobal 宣言しなくても関数内からグローバル変数にアクセスできる例外があります。
それは「参照するだけ」の場合です。例えば以下のようなプログラムはエラーなく実行できます。

```python
x = 5
def print_x():
  print(x)

print_x()
# 5
```

見て分かるように関数内でグローバル変数x を「参照」のみしています。
これは問題ありません。一方、関数内でグローバル変数に「代入」のコードが存在する場合、
代入する前に参照するとエラーになります。

```python
x = 5

# OK
def print_x1():
  print(x)

# OK
def print_x2():
  x = 3
  print(x)

#ERROR
def print_x3():
  y = x + 1
  x = 3
  print(x)
```

上記例だと print_x1, print_x2 は上記エラーとなる条件を満たしません。
一方、print_x3 及び最初に提示した x += 1は条件を満たすためエラーとなるのです。
正直なところ、こんなことまでいちいち意識して関数は書いてほしくありません。
global 変数を参照するだけでも global 宣言を書いたほうが分かりやすいです。

ちなみに「参照のみの場合はグローバル宣言が不要」というルールを生かして、
グローバルレベルにある定数を使うことは全く問題はありません。
なぜなら定数は値が再代入されることがないからです。
ただ、繰り返しますが関数内でグローバルレベルの変数は利用しないべきです。
2つの関数がなにか一つのものをともに利用しないといけないといったケースでは、
ついグローバル変数を関数内で使ってしまいたくなりますが、
これは中編にて扱うクラスを使うことで簡単に解決できます。

## 副作用

難しい話となってしまうのですが、関数などを動かすことで
「期待される範囲を超えた外の世界に影響がおよぶ」ことを「副作用」といいます。
関数の章でも話しましたが、基本的に関数は「入力を受け取って出力を返す」ことをその役割としています。
そのため、関数を動かすことでこの「グローバルレベルの変数x」を変更するのは一般的には副作用だと言えます。

この副作用を減らすことがきれいなコードを書くコツですので、
先ほどのグローバル変数 x を変更するコードであれば、
global宣言を使うより以下のようにするのが一般的です。

```python
x = 5

def add(x):
  return x + 1

print(x)
# 5
x = add(x)
print(x)
# 6
```

こうすることでグローバル変数 x と関数の処理が切り離されます。
最終的にグローバル変数 x は更新されるという点では同じですが、副作用という点では全く異なります。
繰り返しますが、関数内でのグローバル変数へのアクセスは可能な限り避けて下さい。
