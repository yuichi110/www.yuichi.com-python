# raise

{{ TOC }}

## 概要

あいうえお

### 意図的に例外を発生させる

プログラムが自分の意図しない状態になりそうなら、
その処理を中断するために「わざと例外を発生させる」というテクニックがあります。
たとえば簡単に天気予報の情報を得るためのライブラリを自分が書いているとしましょう。
当然ながらネットワークを使って外部から天気予報を取得することになるのでしょうが、
例えばネットワークが繋がっていない場合は天気を取得できません。
その場合、わざと例外を発生させることで「ライブラリを利用する側」に対して例外処理で問題に対応してもらうことができます。
Python はこの「例外を意図的に発生させる」ことを raise キーワードを使うことで実現できます。
簡単なサンプルを見てみます。

```python
try:
  a = 0
  if(a == 0):
    raise Exception('hello')
  5/a
except Exception as e:
  print(type(e))
  print(e)
```

前にお話したように0での除算は禁止されているため、割る前に除数が0でないかをチェックさせています。
そして、それが0であった場合は0 で割ってZeroDivisionErrorにさせるよりも、
「自分がコントロールできる形でわざとエラーとする」ことでZeroDivisionErrorとなることを避けています。
それを実現するためにraiseを使って、その後ろのExceptionを発生させています。
なお、Exceptionに与えられている'hello'はエラーの内容を記載しています。
そのあとのexceptでこのエラーをキャッチできるので、今回はraiseされたExceptionをつかんでいます。

今回は例を簡単にするために発生させる例外を Exception としメッセージも hello でしたが、
実際はエラーに即した例外クラスを使い、メッセージにそのエラー原因を書くことになります。
例外クラスには後述する「自作の例外クラス」を使うことが多いです。

このプログラムの出力は以下のようになります。
helloというメッセージを持つExceptionをキャッチできています。

```
<class 'Exception'>
hello
```

このような処理を見て「どうせエラーになるのだから、
5/0でも raise でもどっちでもいいじゃないか」と思うかもしれません。
ただ、同じエラーであってもraiseでエラーとしている場合は「エラーを意図して発生させている」ことが明確にわかり、
それを自分でコントロールできていることがわかります。
一方、raiseでなく5/aでzeroDivisionErrorエラーが発生し、それをexceptで扱っていると、
それは「コードを読んだ人」にとっては意図せずエラーが発生しているように見えてしまいます。

つまり、たとえ実装者が「期待したエラーハンドリング」だと思っていても、
ほかの人にはそう見えない可能性があるのです。
自分でエラーをコントロールする場合はエラーが発生してしまってから対処するのではなく、
エラーが発生する前に自前に対処をしてしまうようにすべきです。

必ずしもraiseを使う必要はなく、たとえば期待されない値の代わりにデフォルトの設定で動くようにしたり、
場合によっては正しいアウトプットとともにプログラムを停止させてしまったり、
returnで関数を中断させてしまったりなど、さまざまな対処法があります。
ただ、raiseを使うべき場面というものもあるので、その存在だけは知っておいたほうがよいかもしれません。


## キャッチした例外の丸投げ

先に説明したraiseなのですが、もうひとつ別の使い方があります。
それは「exceptの中で呼び出すことで、エラーを呼び出し元で処理してもらう」というものです。
以下のコードを見てください。

```python
def fun1():
  try:
    raise Exception('error in fun1()')
  except:
    print("1: fun1 can't handle this error")
    # 同じエラーを投げる
    raise

def fun2():
  try:
    print('2: call fun1')
    fun1()
    print('3: done')
  except Exception as e:
    print('4: catch error which happens in fun1()')
    print(e)

fun2()
```

関数fun2()はfun1() をその内部で呼び出しています。
fun1() 内部でエラーを発生させて自ら except でそれを受け取っていますが、そのexceptの中でraiseをしています。
こうすると同じエラーが再発生するので、実質的に「呼び出し元に処理を依頼する」ことになります。
一応try/exceptでエラーをハンドルしようとしたけれども「ここでは対処しきれないエラーなので、
呼び出し元で例外処理をしてもらう」というような場合で同じエラーを再度 raise します。

これを実行すると以下のような出力になります。

```
$ python3 test.py
2: call fun1
1: fun1 can't handle this error
4: catch error which happens in fun1()
error in fun1()
```

fun1() の中で再度 raise されたエラーを fun2() が受け取っているので、
例外のメッセージがオリジナルのもののままになっています。
なお、例外を処理しきれない場合は raise で同じものを再度発生させるのではなく別のエラーを raise させても構いません。
例えば適切なエラーメッセージに更新して再度 raise するというのはいいアイデアかもしれません。
