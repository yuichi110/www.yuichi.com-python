## 関数

Pythonに限らず、多くのプログラミング言語には「関数(Function)」という概念があります。
関数は特定の機能を「呼び出す」ために使われます。
たとえば今まで利用していたprint()も関数のひとつで、
()の中に入れた変数や定数をスクリーンに出力するという処理を呼び出します。
本章ではこの関数について扱います。

### 関数の必要性

プログラムは必ず、キーボード入力やファイルの読み込みといった「外からの情報の入力」と、
ディスプレイやスピーカー出力といった「外への情報の出力」を必要としています。
入出力のないプログラムも作れますが、動かしても「プログラムの外の世界」に何も影響がないので、
CPUとメモリを無駄に消費するという目的以外には使えません。
変数や条件分岐といった制御はあくまでもデータを処理するための手段でしかなく、
プログラムの外とやりとりするためには関数が必須です。
先に説明した画面への文字出力を行うprint関数もその一例です。

そして「関数を使わなくても書けるコード」も、うまく関数を使うことで「分かりやすいコード」になります。
例をあげて説明してみます。
絶対値を得ようと思った場合、以下のようにif文で条件分岐させることで実現が可能です。

```python
x = -5
if(x<0):
  x = x * -1
print(x)
# 5
```

2、3行目を見てもらうとわかりますが、「もしxが0より小さければ、xに-1をかける」という処理をしており、
絶対値を得ているということが読み取れます。
同じ処理を、絶対値を得る関数abs()を使って書くと、以下のようになります。

```python
x = abs(-5)
print(x)
# 5
```

前者と後者は同じことを実現していますが、どちらのほうがわかりやすいと思いますか。
圧倒的に後者です。

関数は突き詰めるとその中身は処理の塊だといえます。
ただ、関数の名前はその「処理の要約」なので、
どういう実装で処理が実現されているのかは関数の利用者に隠蔽されています。
たとえばabs()では、「どうやって絶対値を求めるか」を理解していなくても、
それを使えば絶対値が得られることが分かります。
人間の思考能力には限界があるので、ゴチャゴチャとした実装を見せられるよりは、
関数名という要約を見せられたほうが何をやっているか判断しやすくなります。
複雑な処理を隠蔽して機能を分かりやすく提供する、これも関数の利点の1つです。

他にも関数の利用場面は多くあります。
例えばプログラムを書いていると、「同じ処理を何度も使う」という場面が多々あります。
たとえば「2つの数字の絶対値を比較する」というプログラムを作る場合、
関数を使わないと以下のように絶対値を得るコードが2回出現する冗長なものとなります。

```python
x = 5
y = -10

if(x<0):
  x = x * -1
if(y<0):
  y = y * -1

print('abs x > abs y ?')
print(x > y)
# False
```

xとyの絶対値を得る処理はほとんど同じなのにもかかわらず、2回書いています。
2回程度なら書いてもいいような気もしますが、これが5回、10回となればどんどん面倒になっていきます。

先のコードを、関数を使って書き直すと以下のようになります。

```python
x = 5
y = -10

x = abs(x)
y = abs(y)

print('abs x > abs y ?')
print(x > y)
# False
```

冗長な要素が省かれてずいぶんと読みやすくなったのではないでしょうか。
今回はabsのような簡単な関数でしたが、これがたとえば100行以上必要なアルゴリズムだったら、
関数で冗長性を減らすことによる多大な恩恵を得られます。

関数を使わず同じコードを何度もコピペで書いていると、
そのなかに「バグ(プログラムのミス)」があることがわかった場合にすべての場所で修正を施す必要があります。
一方、関数で同じ処理をまとめていると、理想的には一箇所のみの修正となります。
これはプログラムの「保守性(メンテナンス性)」を向上させるというメリットがあります。

### 関数の定義と利用

関数のメリットがわかったところで、関数をどのように作って利用するかを具体的に説明していきます。
以下の図を見てください。

![image](./0045_image/01.jpg)

これが関数の基本的な概念です。関数は入力を受け取り、それを加工して出力する。
基本的にはこれだけです。
先程の関数 abs を自分で作るとしたら、たとえば以下のようなものとなります。

```python
def my_abs(x):
  if(x >= 0):
    return x
  else:
  	return x * -1

print(my_abs(5))
# 5

print(my_abs(-3.3))
# 3.3
```

関数の入力と出力はそれぞれなくてもかまわず、入力がない場合は関数の宣言の引数(入力の宣言)をなくし、
出力が不要な場合はreturn文(出力の宣言)をなくします。

具体的には以下のように関数を定義します。

```python
# 引数がない関数
def my_func1():
  return 0

# 返り値がない関数
def my_func2(x):
  x = x * -1
```

関数をどう呼び出すかについては今までさんざん利用したのでなんとなくわかると思いますが、
宣言した引数に対応する箇所に入力値を入れることで呼び出します。
ひとつ目の変数は引数がないので、呼び出し時に()に何も入れていないものの、
後者は引数をとるので()に値を与えています。
返り値については return されたものが返ってきて、
なにも return されていない場合は None が返ってきます。
この None については後述しますがようするに「なにもない」ということです。

```python
print(my_func1())  
# 0

print(my_func2(5))
# None
```

ほかに知っておくべきこととしては以下のものがあります。
*	引数は複数指定できる
*	return文は一度しか実行されない

これも具体例を示しましょう。

```python
def my_func3(x, y):
  print('A')
  if(x > y):
    return x
  print('B')
  return y

print(my_func3(5,1))
# A
# 5

print(my_func3(2,4))
# A
# B
# 4
```

上記関数では入力値を2つとっています。
コンマで区切られた引数の数のぶんだけ入力を受け付けるという簡単なルールです。
そして、内部では2つのreturn文が確認できます。
注目して欲しいのはx > yの条件を満たす場合はprint('B')が実行されていないということです。
return文はいくつあっても構わないのですが、returnされたあとの関数の処理は一切無視されます。

ほかには「デフォルト引数」や「可変長引数」といった関数の書き方もありますが、
高度なトピックとなるため本書の最後の章にてアドバンスドトピックとして扱います。

### ローカル変数

関数内では引数も含めて変数を宣言できます。
例えば以下の関数があるとしましょう。

```python
def test(x):
  a = x * 2
  return a

print(test(5))
# 10
```

これは与えられた引数を2倍して返すという単純な関数です。
内部に引数(関数内部では変数と同じ扱い)である x と変数 a が存在しています。
実はこれらの変数は関数の外からはアクセスできません。

なんとなくですが、上記の関数を呼び出す前に x や a にアクセスしたら問題が起きそうな気がするのは分かります。
なぜなら、一度も呼ばれていないから x や a になにも入っていないからです。
ただ、実際には関数を呼び出した後であっても関数内の引数や変数に関数外からアクセスすることはできません。

具体的には以下のようなエラーとなります。

```python
print(test(5))
# 10

print(x)
# Traceback (most recent call last):
# ...
# NameError: name 'x' is not defined

print(a)
# Traceback (most recent call last):
# ...
# NameError: name 'a' is not defined
```

重要なことなので覚えておいて下さい。

### グローバル変数

さっそくですが次のコードを見てください。

```python
x = 5

def add():
  x += 1

print(x)
add()
print(x)
```

このプログラムを実行するとどのようになると思いますか。
addという関数がxに1をインクリメントするので、以下のようになるでしょうか。

```
5
6
```

実行してみると分かりますが、実際はエラーが出てしまいます。

```
Traceback (most recent call last):
  File "/Users/yuichi/Desktop/hello.py", line 7, in <module>
    add()
  File "/Users/yuichi/Desktop/hello.py", line 4, in add
    x += 1
UnboundLocalError: local variable 'x' referenced before assignment
```

上記エラーを見ると、関数の中で「変数xに値が与えられる前に参照した」というような内容となっています。
結論から言いますと、プログラム1行目のxと関数内のxは別物です。
そのため関数内のxを使おうとしたところ、エラーが出てしまったのです。
関数内に存在しない1行目の変数xは「グローバルレベル」に存在する変数です。
一方、関数内は「その関数のレベル」で変数などが定義されています。
そのため、グローバルレベルの変数を関数内で使いたい場合は、
関数がそれを利用できるように「global 変数名」と宣言をしてあげる必要があります。
具体的には以下のようになります。

```python
x = 5

def add():
  global x  # global宣言
  x += 1
```

こうすることで、関数の外で定義された変数xを関数の中で利用することができるようになります。
他のプログラミング言語の経験者であればグローバルレベルから関数内の変数を見れないことを知っている人は多いのですが、
Python にはその逆があることを知らないことが時々あるようです。
グローバルレベルと先程説明した関数レベルの変数のアクセスについて以下の図にまとめます。

![image](./0045_image/02.png)

関数内からグローバルは global 宣言すれば見えるが、グローバルレベルから関数内の変数や引数は見えない。
基本的にはこのルールさえ守れば問題ありません。

ただ、実はglobal 宣言しなくても関数内からグローバル変数にアクセスできる例外があります。
それは「参照するだけ」の場合です。例えば以下のようなプログラムはエラーなく実行できます。

```python
x = 5
def print_x():
  print(x)

print_x()
# 5
```

見て分かるように関数内でグローバル変数x を「参照」のみしています。
これは問題ありません。一方、関数内でグローバル変数に「代入」のコードが存在する場合、
代入する前に参照するとエラーになります。

```python
x = 5

# OK
def print_x1():
  print(x)

# OK
def print_x2():
  x = 3
  print(x)

#ERROR
def print_x3():
  y = x + 1
  x = 3
  print(x)
```

上記例だと print_x1, print_x2 は上記エラーとなる条件を満たしません。
一方、print_x3 及び最初に提示した x += 1は条件を満たすためエラーとなるのです。
正直なところ、こんなことまでいちいち意識して関数は書いてほしくありません。
global 変数を参照するだけでも global 宣言を書いたほうが分かりやすいです。

ちなみに「参照のみの場合はグローバル宣言が不要」というルールを生かして、
グローバルレベルにある定数を使うことは全く問題はありません。
なぜなら定数は値が再代入されることがないからです。
ただ、繰り返しますが関数内でグローバルレベルの変数は利用しないべきです。
2つの関数がなにか一つのものをともに利用しないといけないといったケースでは、
ついグローバル変数を関数内で使ってしまいたくなりますが、
これは中編にて扱うクラスを使うことで簡単に解決できます。

### 副作用

難しい話となってしまうのですが、関数などを動かすことで
「期待される範囲を超えた外の世界に影響がおよぶ」ことを「副作用」といいます。
関数の章でも話しましたが、基本的に関数は「入力を受け取って出力を返す」ことをその役割としています。
そのため、関数を動かすことでこの「グローバルレベルの変数x」を変更するのは一般的には副作用だと言えます。

この副作用を減らすことがきれいなコードを書くコツですので、
先ほどのグローバル変数 x を変更するコードであれば、
global宣言を使うより以下のようにするのが一般的です。

```python
x = 5

def add(x):
  return x + 1

print(x)
# 5
x = add(x)
print(x)
# 6
```

こうすることでグローバル変数 x と関数の処理が切り離されます。
最終的にグローバル変数 x は更新されるという点では同じですが、副作用という点では全く異なります。
繰り返しますが、関数内でのグローバル変数へのアクセスは可能な限り避けて下さい。
