# 関数の高度な使い方

{{ TOC }}

## 概要

本章では関数の高度なトピックについて扱います。
正直なところ本章の内容は初心者にはかなり難しいのですが、
Pythonの初心者であっても既存ライブラリなどを利用する場面は多くあるため、
「こういう機能がある」というレベルでは知っておいたほうがいいです。
本トピックは下編で扱うか悩んだのですが、難易度が高いわりに利用する頻度が高いためここで扱わせていただきます。
難しければ斜め読みしていただき、ある程度 Python のプログラムが書けるようになってから読み直してみて下さい。


# 関数型プログラミング

{{ TOC }}

## 概要

本章では今までのオブジェクト指向から若干趣旨を変え、
関数型と呼ばれるプログラミングの概念について扱いたいと思います。
関数型言語にもいくつか種類があり、最古の最も有名なものはLispです。
それ以外にもHaskelやOcaml、そのほかさまざまな言語があります。

Python は関数型言語ではないもののこれらの関数型言語が持つ独特なテクニックが使えます。
例えば後ほど説明する「関数渡し」と「高階関数」、そして map や filter と言った処理、さらには「リスト内包表記」といったものです。
後の章でも扱いますが、この関数型言語のテクニックをオブジェクト指向に取り入れることで、
より綺麗なオブジェクト指向のコードを書くことができるようになります。
オブジェクト指向についての話題はまだ終わっていませんが、ちょうどいい区切りにいるためここで説明いたします。

本章ではまず関数型言語のErlang を使って関数型言語の特徴を説明したあとで、
実際にPythonを使って関数型言語のようなコードを書く方法について説明します。E
rlangは関数型言語であるものの、比較的手続き型言語の文法に似ている言語です。
関数型言語としての側面よりも、並列性や頑健性に優れている言語として有名かもしれません。
関数型の特徴を一言でいってしまうと以下のようなものになります。

*	副作用が発生しにくいコード
*	関数になんでもやらせる

それぞれ簡単に解説してみます。

## 副作用を減らす

言語によって変わってくるかと思いますが、副作用を減らすための関数型の特徴で一番有名なのは
「変数に再代入できない」というものではないかと思います。
たとえばPythonだと以下のコードは問題ありません。

```
>>> num = 5
>>> num = 10
```

一方、Erlangだとこれと同等のことをするコードは以下のような結果となります。(Erlang のシェルを使っています)

```
Eshell V6.3  (abort with ^G)
1> Num = 5.
5
2> Num = 10.
** exception error: no match of right hand side value 10
```

Erlangの補足
* 変数は大文字から始まる
* 文末の . は式の終わりを示す(最初はCやJavaの;と同じという認識でOK)
* 変数の型はPythonと同じく動的に決まる

変数 Num への1度目の代入は問題ありませんが、2度目の代入(再代入)をしようとしてエラーが出ています。
これは正確には代入というよりもパターンマッチの機構に起因してエラーが発生しているのですが、
「Erlangの変数には値を1度しか代入できない」と思っていただければいいと思います。
変数Aの中身を変更したい場合は変数Bを新しく用意してあげる必要があります。
変数を使いまわせないというデメリットもあるのですが、これは変数の中身が常に同じものであることを保証するというメリットがあります。
たとえば「意図しない箇所から内容を書き換えられる(バグ)」は発生しないので、
自分が一度設定した値は最後まで残り続けます。
そのため、デバッグなどもしやすい場合が多いかと思います。

## 関数になんでもやらせる

「関数型」という名前からわかるように、関数型言語ではとにかく関数になんでもやらせます。
たとえば関数を変数に代入したり、高階関数やクロージャといった概念を多用したりします。

たとえば、数列から偶数を見つけるプログラムを書くとしましょう。
今まで学んできたPythonのプログラムだと次のようになると思います。

```python
even_list = []
for i in range(10):
  if(i % 2 == 0):
    even_list.append(i)

print(even_list)
# [0, 2, 4, 6, 8]
```

整数のリストを走査していき、それが偶数の場合は偶数のリストにどんどん追加していっています。
for 文と if 文の組み合わせで実現されています。

これがErlangだと、たとえば以下のように書けます。

```
1> Is_even = fun(X) -> X rem 2 =:= 0 end.
#Fun<erl_eval.6.90072148>

2> Even_list = lists:filter(Is_even, lists:seq(0, 9)).
[0,2,4,6,8]
```

たった2行で python と同じことが実現できています。
このErlangのコードがなにをやっているか説明しましょう。
まず1行目で引数Xが偶数か奇数かを判定する関数を作り、それを変数 Is_even に代入しています。
そして2行目でその変数に代入された関数を[0,1,2..,8,9]というリストに適用して判定がTrueとなった要素だけを取り出しています。
ひと目見ただけでもPythonの手続き型のコードと全然違うことが分かると思います。
関数でリストをフィルタ(条件にマッチしたものだけ取り出す)してあげています。

CやJava(最近のものは別ですが)では、そもそもこういった概念は使えないか、非常に使いにくいものとなっています。
PythonやJavaScriptといった「スクリプト系」の言語はこれらの概念も利用できますが、
あくまでもオマケ的な側面が強いです。一方、関数型はこれらの機能を前面に押し出しています。

長々とErlangの説明をするのも連載の趣旨から外れるのでこのあたりで切り上げたいと思いますが、
要するにfor文などでデータを制御するのではなく、データ構造に対して制御を適用するような処理をします。
個人的な見解ですが、手続き型言語は「制御ありき。データは二の次」というような思想があり、
関数型は「まずデータがあり、それに処理を適用」というような思想があるように思えます。

## Pythonの関数型

Pythonなどのスクリプト系言語は、関数型に近いことがある程度できます。
利用方法は様々ありますが、おおまかには「関数渡しを関数やメソッドのカスタマイズに使う」こと、
それから「リストなどのデータ構造を関数で制御する」ものに分けられます。

Python のデータは全てオブジェクトであるといいましたが、実は関数も「関数型」というオブジェクトです。
他の言語を学ばれたことがある人であれば「え、関数は関数であって型じゃないでしょ?」と思われたかたもしれません。
論より証拠で、さっそく例を示しましょう。

```python
# 関数の定義
def test():
  return 1

print('call test: {}'.format(test()))
# call test: 1
print('type test: {}'.format(type(test)))
# type test: <class 'function'>

# 関数を変数に代入
test2 = test

print('call test2: {}'.format(test2()))
# call test2: 1
print('type test2: {}'.format(type(test2)))
# type test2: <class 'function'>
```

型が'function'とでていて、関数型であることがわかります。
そしてオブジェクトであるため変数への代入もできており、なおかつそれを呼び出すこともできます。
しかし、関数も型だとわかったところで、実際にどのように使うか想像がつかないかもしれません。

### 関数渡し

一番簡単な利用例として関数渡しと呼ばれる使い方を紹介します。
これは Python の「関数もオブジェクトである」という性質を使ったものです。
以下のコードを見て下さい。

```python
# 関数を呼び出す関数 (高階関数)
def fun1(fun, text):
  fun(text)

# 呼び出される普通の関数
def fun2(text):
  print('fun2: ' + text)

# 高階関数に関数を渡して利用
fun1(fun2, 'hello')  
# fun2: 5
```

関数fun1は第一引数で関数、第二引数で文字列を受け取ります。
その受け取った関数を自らの関数内で呼び出しており、その引数に第二引数の文字列を渡しています。
上記の例で呼び出される側の関数 fun2 は普通の関数ですが、呼び出す側の関数は「高階関数」と呼ばれています。
高階(こうかい)というと分かりにくいですが、ようするに関数が2階建てのように使われているとイメージしてもらえれば分かりやすいかもしれません。
高い階層ということなので3階建て以上もできますが、一般的にはやりません。
サンプルでは高階関数を呼び出していますが、
出力を見ると実際に処理をしているのは高階関数内部で呼び出された引数の関数であることがわかります。

このような単純な例だと関数渡しのメリットはあまりないのですが、
自作や一般的なフレームワークの処理の「一部をカスタマイズ」するような場合に利用すると便利です。
たとえばHttpサーバの実装をする際に、「要求を受け取って処理」というのをフレームワークにし、具体的に何の要求か、
その要求に対応するアクションは何かをカスタマイズするという用途などが考えられます。

HTTP サーバを書くと難しすぎるのでカスタマイズ可能な電卓を作ることで「フレームワークの拡張」を体験してみたいと思います。
まず以下の整数用の電卓のクラスがあります。

```python
# フレームワーク (手を加えない)
class Calc:
  # 初期化でカスタマイズ用の関数定義を受取り登録
  def __init__(self, operation_list):
    self.operation_dict = {}
    for operation_tuple in operation_list:
      (operation, method) = operation_tuple
      self.operation_dict[operation] = method

  # イベントドリブンで電卓として動く
  def run(self):
    while True:
      print('please input your calculation')
      input_text = input()
      words = input_text.split()
      if words[0] == 'exit':
        return
      if len(words) < 3:
        continue
      if words[0] not in self.operation_dict:
        continue

      # カスタマイズされた関数を呼び出す
      fun = self.operation_dict[words[0]]
      print(fun(int(words[1]), int(words[2])))
```

このクラスは非常にシンプルですがフレームワークとしてカスタマイズできるようになっています。
まずコンストラクタでタプルの計算処理の定義 (計算の種類, その計算をする関数) をリストで並べたものを渡します。
コンストラクタは辞書データにそれを登録しています。
そしてrun メソッドでは標準入力を読み取り、与えられた計算の種類に応じてその計算をします。
具体的には標準入力を空白で分解し、その一番目の要素に応じた辞書に登録された計算処理を第二、第三の要素に適用するというものです。
たとえば文字列として “plus 2 3” を渡すと 2,3 に対して plus 処理をします。
while True で無限ループになっているため、exit と入力されるまでは永遠に計算が続きます。
ここで注意してほしいのは plus 処理というのはこのクラスの内部には定義されていないことです。
それはこのフレームワークを使う人によりカスタマイズされて初めて使えるようになります。

次にこのフレームワークを利用するために拡張する処理を自分で定義し、
それをコンストラクタで登録します。
今回はコンストラクタで定義しましたが、「メソッドで定義を追加」ということもよくします。

```python
def add(a, b):
  return a + b

def decrease(a, b):
  return a - b

calc = Calc([("plus", add), ("minus", decrease)])
```

関数として add, decrease を定義していて、その処理は足し算引き算となります。
そして先程のフレームワーク Calc を初期化する際にそれらを定義にしたがってリスト上のタプルで登録しています。
今回であれば add を plus という名前で登録しています。

```
calc.run()

please input your calculation
plus 2 3
5
please input your calculation
minus 5 2
3
please input your calculation
exit
```

作成したインスタンスの run メソッドを呼び出すと自分で定義した処理が呼び出せていることが分かります。
同じ要領で掛け算や割り算、もっと複雑な計算も定義できます。

前書の最初のほうで Python プログラムの体験として以下のような
 GUI のプログラムの紹介をしており、それは以下のようなものでした。

![image](./1055_image/01.png)

真ん中にあるボタンを押すと、数字がどんどん増えていくという簡単なカウンターアプリケーションです。
このアプリケーションのプログラムは以下のようなものとなっています。

```python
import tkinter

counter = 0
font = ("Helevetica", 32, "bold")
button = tkinter.Button(font=font, text=str(counter))

# 処理を作成(カウンターの数字を増やす)
def clicked():
  global counter, button
  counter = counter + 1
  button.config(text=str(counter))

# GUI のライブラリに処理を登録
button.config(command=clicked)
button.pack()
button.mainloop()
```

この GUI のライブラリはクリックされた時の処理を登録できるようになっており、
自分でその処理をする関数を定義し、それをボタンが押された時のアクションとして登録しています。
こうすることで GUI のアプリケーションの動きを自分でカスタマイズしているのです。
GUI 自体の実装は先程の電卓プログラムよりはるかに複雑なのですが、
カスタマイズをするだけであれば先ほどの電卓の例とそれほど違いはありません。
このようなことができるのが「関数渡し」や「高階関数」の強さだと言えます。
