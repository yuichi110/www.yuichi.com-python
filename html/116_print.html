<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="Sample Description" name="description"/>
  <link href="./assets/favicon.ico" rel="icon"/>
  <title>
   Python入門
  </title>
  <link href="./assets/css/bootstrap.css" rel="stylesheet">
   <link href="./assets/css/codehilite_colorful.css" rel="stylesheet"/>
  </link>
 </head>
 <body>
  <!-- GENERATED HTML START -->
  <h2>
   クラスの高度なトピック
  </h2>
  <h3>
   概要
  </h3>
  <p>
   この章では今まで扱わなかったクラスの高度なトピックについて扱います。
それらは初心者にとってはオブジェクト指向を実現するうえで必ず必要なものではないものの、
中級者以上のコードを読み書きする際に必要となることがあります。
まずは「こういったこともできる」という程度のものかと認識していただければ十分です。
  </p>
  <h3>
   クラス変数
  </h3>
  <p>
   今までのクラス内での変数は「インスタンス変数」であり、インスタンスごとに独立したものでした。
クラスにはインスタンス変数に加えて「クラス変数」というものがあり、それは全てのインスタンスで共有されています。
つまり同じクラスから作成されたインスタンス a, b があるとすると、a がその変数を変更すると b のものも変更されるということです。
以下にインスタンス変数とクラス変数を使ったサンプルコードを記載します。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
  <span class="c1"># クラス変数の定義</span>
  <span class="n">a</span> <span class="o">=</span> <span class="s1">'A'</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="s1">'B'</span>

  <span class="k">def</span> <span class="nf">set_ab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="c1"># クラス変数の利用</span>
    <span class="n">MyClass</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>

  <span class="k">def</span> <span class="nf">print_ab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
</pre>
  </div>
  <p>
   コメントにあるように上記の変数 a がクラス変数で、変数 b が今まで使っていたインスタンス変数です。
使い方を見てもらうと分かりますが、クラス変数の定義はクラスの直下(メソッドと同じブロック)で行い、
定義したクラスを利用するには「クラス名.変数名」としています。
定義と利用はそれほど難しくないと思うので、さっそくクラス変数を使ってみます。
上記コードにある set_ab メソッドでクラス変数とインスタンス変数を更新し、print_ab でその中身を確認します。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="n">mycls_a</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="n">mycls_b</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>

<span class="n">mycls_a</span><span class="o">.</span><span class="n">print_ab</span><span class="p">()</span>
<span class="c1"># A</span>
<span class="c1"># B</span>
<span class="n">mycls_b</span><span class="o">.</span><span class="n">print_ab</span><span class="p">()</span>
<span class="c1"># A</span>
<span class="c1"># B</span>

<span class="c1"># クラス変数とインスタンス変数を更新</span>
<span class="n">mycls_a</span><span class="o">.</span><span class="n">set_ab</span><span class="p">(</span><span class="s1">'AA'</span><span class="p">,</span> <span class="s1">'BB'</span><span class="p">)</span>

<span class="n">mycls_a</span><span class="o">.</span><span class="n">print_ab</span><span class="p">()</span>
<span class="c1"># AA</span>
<span class="c1"># BB</span>
<span class="n">mycls_b</span><span class="o">.</span><span class="n">print_ab</span><span class="p">()</span>
<span class="c1"># AA</span>
<span class="c1"># B</span>
</pre>
  </div>
  <p>
   インスタンス化された直後のクラス変数とインスタンス変数は初期状態のため、
2つのインスタンスで値は全く同じです。
そのあとで片方のインスタンスに対して set_ab で値を更新し、
両方のインスタンスの2つの変数 a, b の値を確認するとクラス変数のみ変更を加えていない側のインスタンスでも更新されていることがわかります。
この特性から全てのインスタンスで共有したい値にはクラス変数を使い、
各インスタンスで独立した値を持ちたい場合はインスタンス変数を使えばいいことが分かります。
なお、クラス変数はインスタンスに依存しないため、クラスから直接呼び出すこともできます。
たとえば先程のクラスだと以下のようになります。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="c1"># インスタンスから呼び出し</span>
<span class="n">mycls_a</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">mycls_a</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># AA</span>

<span class="c1"># クラスから直接呼び出し</span>
<span class="k">print</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># AA</span>
</pre>
  </div>
  <p>
   クラス変数や今後扱うクラス定数、クラスメソッドなどは概念的には以下の図の緑にあたります。
一方、従来のインスタンス変数やインスタンスメソッドはオレンジに属しています。
  </p>
  <p class="blog-img">
   <img alt="image" class="img-responsive" src="./1080_image/01.png"/>
  </p>
  <p>
   クラス外に定義されている変数や関数はグローバル空間に属しています。
前書で説明した global 宣言なども関わってくるため、値のアップデートは極力避けて参照をするのみにしてください。
  </p>
  <h3>
   クラス定数
  </h3>
  <p>
   クラス変数は変数名を大文字にすることで「クラス定数」としても利用できます。
以下にサンプルコードを記載します。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="k">class</span> <span class="nc">Calc</span><span class="p">:</span>
  <span class="c1"># クラス定数の定義</span>
  <span class="n">TAX_RATE</span> <span class="o">=</span> <span class="mf">1.08</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut_rate</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cut_rate</span> <span class="o">=</span> <span class="n">cut_rate</span>

  <span class="k">def</span> <span class="nf">get_price</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag_price</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">tag_price</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut_rate</span> <span class="o">*</span> <span class="n">Calc</span><span class="o">.</span><span class="n">TAX_RATE</span><span class="p">)</span>

<span class="n">taro_calc</span> <span class="o">=</span> <span class="n">Calc</span><span class="p">(</span><span class="mf">0.95</span><span class="p">)</span>
<span class="n">jiro_calc</span> <span class="o">=</span> <span class="n">Calc</span><span class="p">(</span><span class="mf">0.9</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">taro_calc</span><span class="o">.</span><span class="n">get_price</span><span class="p">(</span><span class="mi">10000</span><span class="p">))</span>
<span class="c1"># 10260</span>
<span class="k">print</span><span class="p">(</span><span class="n">jiro_calc</span><span class="o">.</span><span class="n">get_price</span><span class="p">(</span><span class="mi">10000</span><span class="p">))</span>
<span class="c1"># 9720</span>
</pre>
  </div>
  <p>
   上記の例は顧客ごとに商品の値段を求めるサンプルです。
各顧客はそれぞれ異なる割引率を持っており、それはインスタンス変数として定義されています。
一方、税率 TAX_RATEはどの顧客でも変わらないためクラス定数として持たせています。
クラス定数は基本的に普通の定数と同じルールで使います。
普通の定数との違いは単にクラスの中にあるということだけです。
前書でもお話したように python には本当の意味での「定数(値を変えられない変数)」はなく、
大文字の変数名の変数を上書きしないというプログラマのルールで変数を定数として使っています。
そのため、既に定義をされた定数は絶対に上書きしないで下さい。
  </p>
  <p>
   クラス定数の便利な使い方に「クラス定数のみを持つクラス」があります。
たとえばプログラムで色コードが必要な場合、それをまとめて1つのクラスにクラス変数として定義してしまい、
それを他のプログラムが利用するといった使いかたが考えられます。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="k">class</span> <span class="nc">Color</span><span class="p">:</span>
  <span class="n">BLACK</span> <span class="o">=</span> <span class="s1">'000000'</span>
  <span class="n">GRAY</span> <span class="o">=</span> <span class="s1">'808080'</span>
  <span class="n">WHITE</span> <span class="o">=</span> <span class="s1">'ffffff'</span>
  <span class="n">BLUE</span> <span class="o">=</span> <span class="s1">'0000ff'</span>
  <span class="n">GREEN</span> <span class="o">=</span> <span class="s1">'00ff00'</span>
  <span class="n">RED</span> <span class="o">=</span> <span class="s1">'ff0000'</span>

<span class="k">print</span><span class="p">(</span><span class="n">Color</span><span class="o">.</span><span class="n">RED</span><span class="p">)</span>
<span class="c1"># ff0000</span>

<span class="k">print</span><span class="p">(</span><span class="n">Color</span><span class="o">.</span><span class="n">BLACK</span><span class="p">)</span>
<span class="c1"># 000000</span>
</pre>
  </div>
  <p>
   色を必要とするクラスが複数ある場合、それらのクラスは上記のようなクラスを参照して色を使えば、
複数のクラス間で一貫した色の扱いをすることができます。
  </p>
  <h3>
   クラスメソッド
  </h3>
  <p>
   クラスメソッドはインスタンス化しなくても使えるメソッドです。
今までメソッドを利用する場合はまずクラスからインスタンスを作成し、そのインスタンスからメソッドを呼び出していました。
ただ、その呼び出されるメソッドがその内部でインスタンス変数を使わない場合、そのメソッドはインスタンスに依存しないといえます。
ちょっと難しいのでコードで確認してみます。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>

  <span class="c1"># インスタンスに依存するメソッド</span>
  <span class="k">def</span> <span class="nf">print_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>

  <span class="c1"># インスタンスに依存しないメソッド</span>
  <span class="k">def</span> <span class="nf">print_hello</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">)</span>
</pre>
  </div>
  <p>
   上記クラスはインスタンス変数 a を持ちます。print_a はそのインスタン変数を使っているので、
その結果はインスタンスごとに変わってきます。
たとえば初期化時に 10 を与えたインスタンスであれば 10 と出力されるでしょうが、
5を与えられたインスタンスであれば 5 と出力されます。
一方、print_hello メソッドは内部でインスタンスに依存する変数やメソッドを一切使っていないため、
このクラスのインスタンスのどれから呼び出されようと結果は必ず同じです。
  </p>
  <p>
   クラスメソッドは上記のような「どのインスタンスから呼ばれても結果が同じ」というメソッドに使うべきテクニックです。
通常のメソッド(インスタンスメソッド)ではなくクラスメソッドとして定義をするとインスタンス化せずにメソッドを呼び出せます。
クラスメソッドは以下のように定義します。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
  <span class="n">a</span> <span class="o">=</span> <span class="s1">'A'</span>

  <span class="c1"># @ を使ってクラスメソッドとして定義</span>
  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">print_hello</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>
</pre>
  </div>
  <p>
   今までのメソッドと違ってメソッドの定義の前に「@classmethod」というものがあります。
これは実はプロパティと呼ばれている「関数やメソッドがどう動くかを定義する宣言」の1つなのですが、
プロパティの詳細は初心者向けではないため下編に譲ります。
現時点ではとりあえずこう使うとだけ覚えておいて下さい。
クラスメソッドの宣言は通常のメソッドでは self であった箇所が cls になっています。
これは通常のメソッドはインスタンスが第一引数に渡されるのに対し、クラスメソッドはクラス自身が第一引数に渡されるからです。
  </p>
  <p>
   クラスメソッドの呼び出しは簡単で、「クラス.クラスメソッド()」とするだけです。
上記のサンプルだと以下のようになります。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="n">MyClass</span><span class="o">.</span><span class="n">print_hello</span><span class="p">()</span>
<span class="c1"># A</span>
<span class="c1"># &lt;class 'type'&gt;</span>
</pre>
  </div>
  <p>
   クラスメソッドはインスタンス(引数selfに入っていた)を受け取れないため、
インスタンス変数やインスタンスメソッドは利用できません。
ただ、引数cls を使ってクラス変数や他のクラスメソッドにはアクセスできます。
  </p>
  <p>
   なお、クラス変数を self を経由して参照することも可能です。
ただし、これは「同名のインスタンス変数が存在しない場合」のみです。
例えば以下のようなコードがあるとしましょう。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
  <span class="n">a</span> <span class="o">=</span> <span class="s1">'A'</span>

  <span class="k">def</span> <span class="nf">print_self_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">set_self_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>

  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">print_cls_a</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>

  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">set_cls_a</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="bp">cls</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
</pre>
  </div>
  <p>
   コードを読んでもらうと分かりますが、以下のような構成となっています。
  </p>
  <ul>
   <li>
    a というクラス変数がある
   </li>
   <li>
    インスタンス変数 a に対する set, print がある
   </li>
   <li>
    クラス変数 a に対する set, print がある
   </li>
  </ul>
  <p>
   普通に考えると「クラス変数に対する set, print は問題なし。
インスタンス変数に対する print は set されるまでは失敗する」と動きそうなところですが、実はそうは動きません。
先に言ったように「インスタンス変数が存在しない場合は self からクラス変数を参照できる」ためです。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="n">mc1</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="n">mc2</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="n">mc1</span><span class="o">.</span><span class="n">print_self_a</span><span class="p">()</span>
<span class="c1"># A</span>
<span class="n">mc2</span><span class="o">.</span><span class="n">print_self_a</span><span class="p">()</span>
<span class="c1"># A</span>
</pre>
  </div>
  <p>
   上記コードの出力を見てもらうとわかるようにインスタンス変数の参照が実質的にクラス変数を見ていることが分かります。
ただ、代入をすると話が変わってきます。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="n">mc1</span><span class="o">.</span><span class="n">set_self_a</span><span class="p">(</span><span class="s1">'AA'</span><span class="p">)</span>
<span class="n">mc1</span><span class="o">.</span><span class="n">print_self_a</span><span class="p">()</span>
<span class="c1"># AA</span>
<span class="n">mc1</span><span class="o">.</span><span class="n">print_cls_a</span><span class="p">()</span>
<span class="c1"># A</span>
</pre>
  </div>
  <p>
   インスタンス変数に値を代入すると、インスタンス変数の a とクラス変数の a が同時に存在するようになります。
self.a が新しく代入された値を持っているのに対し、cls.a はもともとの値を持ち続けていることからも分かります。
上記のインスタンス変数への代入は当然ながら別の同一クラスのインスタンスには影響は及ぼしません。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="n">mc2</span><span class="o">.</span><span class="n">print_self_a</span><span class="p">()</span>
<span class="c1"># A</span>
<span class="n">mc2</span><span class="o">.</span><span class="n">print_cls_a</span><span class="p">()</span>
<span class="c1"># A</span>
</pre>
  </div>
  <p>
   self を経由したクラス変数へのアクセスは思わぬトラブルのもとになります。
大文字のため一目で分かり、絶対に上書きがされないクラス定数以外では利用をしないほうがよいでしょう。
  </p>
  <h3>
   スタティックメソッド
  </h3>
  <p>
   クラスメソッドに似た性質を持つスタティックメソッドというものもあります。
簡単に言ってしまうとスタティックメソッドは「クラスメソッドの第一引数がない版」のようなものです。
そのため、引数cls を使ってクラス変数やクラスメソッドにアクセスできないため、アクセスするには「クラス名.属性」とします。
宣言は @classmethod の代わりに @staticmethod とします。
以下にサンプルを記載します。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
  <span class="n">a</span> <span class="o">=</span> <span class="s1">'A'</span>

  <span class="c1"># @ を使ってスタティックメソッドとして定義</span>
  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">print_a</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>

<span class="n">MyClass</span><span class="o">.</span><span class="n">print_a</span><span class="p">()</span>
<span class="c1"># A</span>
</pre>
  </div>
  <p>
   スタティックメソッドはある種の処理をまとめたユーティリティ用のクラスを作るときに便利です。
クラスのメソッドがインスタンス変数もクラス変数も全く使わない場合、
それをスタティックメソッドにしてしまうと余計な引数の定義がいらなくなります。
このユーティリティ用のクラスは例えば以下のような形になります。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="k">class</span> <span class="nc">MyUtil</span><span class="p">:</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">function1</span><span class="p">():</span>
    <span class="k">pass</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">function2</span><span class="p">():</span>
    <span class="k">pass</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">function3</span><span class="p">():</span>
    <span class="k">pass</span>
</pre>
  </div>
  <p>
   MyUtil というクラスがグループ名で各メソッドが個々の処理になります。
インスタンス変数やクラス変数を使わないため、それぞれの処理は完全に独立しているものの、
同じジャンルの処理をクラスにまとめているといった形です。
ある作業をまとめたモジュールに無数の関数が定義されているのと似ています。
  </p>
  <p>
   なお、クラスメソッドやスタティックメソッドは継承と関わると話が複雑になります。
興味がある人は調べてみるとよいかもしれませんが、そんな詳細まで把握している人は限られているため、使わないほうがよいと思います。
  </p>
  <h3>
   メソッドのオーバーロード(デフォルト引数)
  </h3>
  <p>
   オブジェクト指向にはオーバーロードと呼ばれている概念があります。
オーバーライドと名前が似ているので注意してください。
オーバーロードを簡単に言ってしまうと「あるクラスに同名の引数が異なるメソッドを複数宣言すると、
呼び出し時の引数に応じて呼び出されるメソッドが変わる」というものです。
実はオーバーロードは Python にはありません。
ただ、オーバーロード相当のことは「デフォルト引数」や「可変長引数」などを使うことで実現できます。
以下にデフォルト引数を使ったオーバーロードもどきのサンプルを張ります。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">'C'</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="s1">'D'</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre>
  </div>
  <p>
   関数の可変長引数については前書で説明したためここでは詳細は扱いませんが、対応する引数を与えればそれになり、
あたえなければ = の後のデフォルト値になるという動きをします。
メソッドも同じことができます。
使用例は以下のようになります。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="n">mc</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="n">mc</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="s1">'AA'</span><span class="p">,</span> <span class="s1">'BB'</span><span class="p">)</span>
<span class="c1"># AA BB C D</span>

<span class="n">mc</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="s1">'AA'</span><span class="p">,</span> <span class="s1">'BB'</span><span class="p">,</span> <span class="s1">'CC'</span><span class="p">)</span>
<span class="c1"># AA BB CC D</span>
</pre>
  </div>
  <p>
   見てもらうと分かるように同名のメソッドを引数2でも引数3 でも呼び出すことができています。
  </p>
  <h4>
   クラスの特殊属性
  </h4>
  <p>
   今までも利用してきたようにクラスやインスタンスには特殊な変数やメソッドがあります。
例えば
   <code>
    def __init__(self)
   </code>
   として定義されたメソッドはコンストラクタとして動くという「特殊な決まり」があります。
その他にも継承でお話したように
   <code>
    __class__
   </code>
   というインスタンス変数はクラス名を返します。
  </p>
  <p>
   実はPythonではアンダースコア2つで囲われた変数やメソッドは特別な意味を持っています。
そして、そういったメソッドはオーバーライドをすることができます。
以下にサンプルコードを記載します。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="k">class</span> <span class="nc">Customer</span><span class="p">:</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

  <span class="k">def</span> <span class="nf">print_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'name: '</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'age:  '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="p">))</span>
</pre>
  </div>
  <p>
   まず上記のクラス Customer があるとします。インスタンス変数として name と age を持ち、
それらを表示するためのメソッド print_info もあります。
このクラスの情報を表示しようと思ったら print_info メソッドを呼び出す必要があり、
print 文にこのオブジェクトを渡しても自分が期待するような出力は得られません。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">Customer</span><span class="p">(</span><span class="s1">'taro'</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">print_info</span><span class="p">()</span>
<span class="c1"># name: taro</span>
<span class="c1"># age:  25</span>

<span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="c1"># &lt;__main__.Customer object at 0x1019d8b38&gt;</span>
</pre>
  </div>
  <p>
   print文の出力を見てもらうと分かりますが、たんにオブジェクトの場所を表示しているだけです。
この挙動を変えるために特殊メソッド
   <code>
    __str__()
   </code>
   をオーバーライドします。
先に説明しましたが継承を明示的にしていないクラスは object というクラスを継承しています。
   <code>
    __str__()
   </code>
   は object にてアドレス番地を出力するように実装されているので、自分のクラスでその挙動を上書きします。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="k">class</span> <span class="nc">Customer</span><span class="p">:</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

  <span class="c1"># 特殊メソッドのオーバーライド</span>
  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">'name:{}, age:{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Customer</span><span class="p">(</span><span class="s1">'taro'</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="c1"># name:taro, age:25</span>
</pre>
  </div>
  <p>
   新しく
   <code>
    __str__()
   </code>
   メソッドを定義したことで str() 関数で文字列化した場合に返される値が定義したフォーマットとなり、
print 文もその恩恵に預かります。
  </p>
  <p>
   特殊属性の詳細は高度な話題となるため後編にて詳細を扱いますが、そのようなものが存在しているということは覚えておいて下さい。
  </p>
  <h4>
   多重継承
  </h4>
  <p>
   Pythonのクラスは2つのクラスを継承することができます。
存在は知っておいて欲しいですが、これを禁止している言語もあるので あまり積極的に使って欲しくはない機能です。
  </p>
  <div class="codehilite">
   <pre><span></span><span class="k">class</span> <span class="nc">Parent1</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">print_hello</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Parent2</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">print_world</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'world'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Parent1</span><span class="p">,</span> <span class="n">Parent2</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">print_python</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'python'</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Child</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">print_hello</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">print_world</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">print_python</span><span class="p">()</span>
<span class="c1"># hello</span>
<span class="c1"># world</span>
<span class="c1"># python</span>
</pre>
  </div>
  <!-- GENERATED HTML END -->
 </body>
</html>
